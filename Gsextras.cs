  

((Smalltalk includesKey: #HmChangesInSystem) and:
 [(Smalltalk at: #HmChangesInSystem) isKindOf: (Smalltalk at: #HmChangeSet)])
      ifTrue: [(Smalltalk at: #HmChangesInSystem) comment: 'Undocumented'.
(Smalltalk at: #HmChangesInSystem) name: 'GsExtras'.
(Smalltalk at: #HmChangesInSystem) pathName: 'GSEXTRAS.CS'.
(Smalltalk at: #HmChangesInSystem) preActions: ''.
(Smalltalk at: #HmChangesInSystem) postActions: '']
!

Object subclass: #GsFacade
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''  !


Object subclass: #GsAbstractModel
  instanceVariableNames: 
    'isPersistent '
  classVariableNames: ''
  poolDictionaries: ''  !


Object subclass: #GsEventHandlerManager
  instanceVariableNames: ''
  classVariableNames: 
    'HandlerTable '
  poolDictionaries: ''    !


Object subclass: #GsBusinessObject
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''    !


ViewManager subclass: #ClassHierarchyBrowser
  instanceVariableNames: 
    'originalClasses browsedClasses selectedClass instanceSelectedLast selectedMethod methodSelectedLast hiddenClasses selectedInstVar assigned used '
  classVariableNames: ''
  poolDictionaries: ''    !


GsFacade subclass: #GsMethodParser
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''    !


GsFacade subclass: #GsMethodGenerator
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: '' !


GsFacade subclass: #GsClassHierarchyRouter
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''    !


ViewManager subclass: #GsAbstractViewManager
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''  !


GsAbstractModel subclass: #GsModel
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''    !


GsFacade subclass: #GsPartNameGenerator
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''   !


GsAbstractViewManager subclass: #GsViewManager
  instanceVariableNames: 
    'parentView model '
  classVariableNames: ''
  poolDictionaries: '' !


GsViewManager subclass: #GsSendersView
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    'ColorConstants WBConstants '   !


GsViewManager subclass: #GsMethodGeneratorSelectionView
  instanceVariableNames: 
    'possibleVars selectedVars objectClass '
  classVariableNames: ''
  poolDictionaries: 
    'ColorConstants WBConstants '  !


FixedSizeCollection variableByteSubclass: #String
  classVariableNames: ''
  poolDictionaries: 
    'CharacterConstants WinConstants '    !


GsViewManager subclass: #GsMoveClassView
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    'ColorConstants WBConstants ' !


GsViewManager subclass: #GsImplementorsView
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    'ColorConstants WBConstants '  !


GsViewManager subclass: #GsPartNameListView
  instanceVariableNames: 
    'allPartNames viewClass '
  classVariableNames: ''
  poolDictionaries: 
    'ColorConstants WBConstants ' !


GsViewManager subclass: #GsRenameClassView
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    'ColorConstants WBConstants '   !


CompositePane subclass: #GsCompositePane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: ''  !


GsCompositePane subclass: #GsEntryFieldCompositePane
  instanceVariableNames: ''
  classVariableNames: ''
  poolDictionaries: 
    'ColorConstants WBConstants ' !



!GsRenameClassView methods !

 
cancelPushButtonClicked: aPane

    "Callback for the #clicked event in the Button named 'cancelPushButton'.
     (Generated by WindowBuilder)"


    self closeWindow.!  !



!GsRenameClassView methods !

 
okPushButtonClicked: aPane

    "Callback for the #clicked event in the Button named 'okPushButton'.
     (Generated by WindowBuilder)"

    | stringTheyTyped |

    stringTheyTyped := (self paneNamed: 'newNameEntryField') contents.

    ((stringTheyTyped isEmpty
        or: [(stringTheyTyped trimBlanks at: 1) isLowerCase])
        or:[(stringTheyTyped trimBlanks at: 1) isDigit])
    ifTrue:[
        ^MessageBox
            message: 'Classes should start with a capital letter!!' ].

    self model rename: stringTheyTyped.
    self closeWindow.! !



!GsRenameClassView methods !

 
createViews

     "WARNING!!  This method was automatically generated by
      WindowBuilder.  Code you add here which does not conform
      to the WindowBuilder API will probably be lost the next time
      you save your layout definition."

     | v |

    self addView: (
        v := self topPaneClass new
            owner: self;
            labelWithoutPrefix:  'Rename Class';
            noSmalltalkMenuBar;
            viewName: 'mainView';
            framingBlock: ( FramingParameters new iDUE: 686 @ 400; xC; yC; cRDU: (2 @ 398 rightBottom: 683 @ 40));
            pStyle: #(sysmenu titlebar);
            addSubpane: (
                Button new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 146 @ 64; lDU: 503 r: #left; rDU: 649 r: #left; tDU: 264 r: #top; bDU: 328 r: #top);
                    paneName: 'cancelPushButton';
                    idCancel;
                    startGroup;
                    when: #clicked perform: #cancelPushButtonClicked:;
                    contents: 'Cancel';
                    yourself
            );
            addSubpane: (
                Button new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 146 @ 64; lDU: 320 r: #left; rDU: 466 r: #left; tDU: 264 r: #top; bDU: 328 r: #top);
                    paneName: 'okPushButton';
                    idOK;
                    startGroup;
                    when: #clicked perform: #okPushButtonClicked:;
                    contents: 'Ok';
                    yourself
            );
            addSubpane: (
                EntryField new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 631 @ 48; lDU: 18 r: #left; rDU: 649 r: #left; tDU: 104 r: #top; bDU: 152 r: #top; indent: 3 @ 4);
                    paneName: 'newNameEntryField';
                    startGroup;
                    yourself
            );
            addSubpane: (
                StaticText new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 512 @ 32; lDU: 18 r: #left; rDU: 530 r: #left; tDU: 48 r: #top; bDU: 80 r: #top);
                    paneName: 'newNameLabel';
                    startGroup;
                    contents: 'Enter the New Name for the class:';
                    yourself
            );
        yourself
    ).!   !



!GsModel methods !

   
printString

    self canUnderstand: #displayString
        ifTrue:[
            ^self displayString]
        ifFalse:[
            ^super printString]!  !



!Object methods !


signalEvent: anEvent with: anObject

    GsEventHandlerManager processEvent: anEvent for: self with: (Array with: anObject).! !



!Object methods !


gsWhen: anEvent perform: aMessage

    GsEventHandlerManager atEvent: anEvent putMessage: aMessage for: self.!    !



!GsMoveClassView class methods !

 
wbCreated

    ^true! !



!GsMoveClassView class methods !

 
openOn: aClass parentView: aView

    ^self new
        model: aClass;
        parentView: aView;
        open;
        yourself.!    !



!GsPartNameGenerator class methods !

 
generatePartNameFor: aPartName

    | aStream |
    aStream := WriteStream on:''.
    aStream nextPutAll: '(self paneNamed: '''.
    aStream nextPutAll: aPartName asString.
    aStream nextPutAll: ''')'.
    ^aStream contents asString.! !



!GsPartNameGenerator class methods !

 
partNameOnClipBoard: aPartName

    | partString |

    partString := self generatePartNameFor: aPartName.
    Clipboard setString: partString.!   !



!GsPartNameGenerator class methods !

 
allComponentsFor: anViewInstance
    "Answer all of the components for a view instance
    by parsing the class's instance view methods and then
    getting the parts out of anViewInstance"

    | partNames components |

    partNames := self allSubViewPartNamesInClass: anViewInstance class.
    components := Set new.
    partNames do:[:e |
        components add: (anViewInstance paneNamed: e)].

   ^components! !



!GsPartNameGenerator class methods !

 
generateMethodForPartSetter: aPartName
    forClass: aClass

    ^GsMethodGenerator generateMethodForPartSetter: aPartName forClass: aClass! !



!GsPartNameGenerator class methods !

 
allSubViewPartNamesInClass: aViewClass

    ^GsMethodParser allSubViewPartNamesInClass: aViewClass.!  !



!GsPartNameGenerator class methods !

 
generateMethodForPartGetter: aPartName
    forClass: aClass

    ^GsMethodGenerator generateMethodForPartGetter: aPartName forClass: aClass! !



!GsMoveClassView methods !

   
duplicateSuperclassClassVars: aSuperClass in: aClass

    | myOC subclassOC |

    myOC := OrderedCollection new.
    subclassOC := Set new.

    aClass withAllSubclasses do:[:e |
        subclassOC  addAll: e classVarNames].

    aSuperClass allClassVarNames asOrderedCollection do:[:e |
    myOC addAll: (subclassOC asOrderedCollection select:[:eIn | eIn = e])].
    myOC isEmpty
        ifFalse:[
                MessageBox message: 'There are duplicate instance or class variables!!'.
                ^true].

    ^false!  !



!GsMoveClassView methods !

   
okPushButtonClicked: aPane
    "Callback for the #clicked event in the Button named 'okPushButton'.
     (Generated by WindowBuilder)"

    | anOC newSuperClass sharedPoolString newClass modelSubclasses |

    newSuperClass :=
        Smalltalk
            at: ((self paneNamed: 'superclassEntryField') contents asSymbol)
            ifAbsent: [nil].
    "Make sure the class exists"
    (newSuperClass isNil)
        ifTrue:[^self classDoesNotExist].

    "Make sure there aren't any duplicate instance variables"
    (self duplicateSuperclassInstVars: newSuperClass in: self model)
        ifTrue:[^self].

    "Make sure there aren't any duplicate class instance variables"
    (self duplicateSuperclassClassVars: newSuperClass in: self model)
        ifTrue:[^self].

    self moveClass: self model toNewSuperclass: newSuperClass .

    "Close the window"
    self closeWindow.! !



!GsMoveClassView methods !

   
createViews

     "WARNING!!  This method was automatically generated by
      WindowBuilder.  Code you add here which does not conform
      to the WindowBuilder API will probably be lost the next time
      you save your layout definition."

     | v |

    self addView: (
        v := self topPaneClass new
            owner: self;
            labelWithoutPrefix:  'Move Class';
            noSmalltalkMenuBar;
            viewName: 'mainView';
            framingBlock: ( FramingParameters new iDUE: 686 @ 400; xC; yC; cRDU: (2 @ 398 rightBottom: 683 @ 40));
            pStyle: #(sysmenu titlebar);
            addSubpane: (
                Button new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 146 @ 64; lDU: 503 r: #left; rDU: 649 r: #left; tDU: 264 r: #top; bDU: 328 r: #top);
                    paneName: 'cancelPushButton';
                    idCancel;
                    startGroup;
                    when: #clicked perform: #cancelPushButtonClicked:;
                    contents: 'Cancel';
                    yourself
            );
            addSubpane: (
                Button new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 146 @ 64; lDU: 320 r: #left; rDU: 466 r: #left; tDU: 264 r: #top; bDU: 328 r: #top);
                    paneName: 'okPushButton';
                    idOK;
                    startGroup;
                    when: #clicked perform: #okPushButtonClicked:;
                    contents: 'Ok';
                    yourself
            );
            addSubpane: (
                EntryField new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 631 @ 48; lDU: 18 r: #left; rDU: 649 r: #left; tDU: 104 r: #top; bDU: 152 r: #top; indent: 3 @ 4);
                    paneName: 'superclassEntryField';
                    startGroup;
                    yourself
            );
            addSubpane: (
                StaticText new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 402 @ 32; lDU: 18 r: #left; rDU: 421 r: #left; tDU: 48 r: #top; bDU: 80 r: #top);
                    paneName: 'nameOfNewSuperClassLabel';
                    startGroup;
                    contents: 'Name Of New Superclass:';
                    yourself
            );
        yourself
    ).!    !



!GsMoveClassView methods !

   
buildSharedPoolsStringFor: aClass
    | newStream |
    newStream := WriteStream on:''.
    aClass sharedPools do:[:e |
        newStream nextPutAll: e printString.
        newStream nextPutAll: ' '.].
    ^newStream contents asString.!  !



!GsMoveClassView methods !

   
cancelPushButtonClicked: aPane

    "Callback for the #clicked event in the Button named 'cancelPushButton'.
     (Generated by WindowBuilder)"


     self closeWindow.! !



!GsMoveClassView methods !

   
classDoesNotExist

    ^MessageBox message: 'The class that you typed does not exist!!'!  !



!GsMoveClassView methods !

   
moveClass: moveClass toNewSuperclass: newSuperClass

     |this clas newSuper newString theClassesToInstall|
    this := ReadWriteStream on: ''.
    clas := moveClass.
    newSuper := newSuperClass name asString.
        clas withAllSubclasses do: [:c |
            c fileOutOn: this.
            this nextChunkPut: String new.
            (ClassReader forClass: c class) fileOutOn: this.
            (ClassReader forClass: c) fileOutOn: this].

    newString := this collection replaceSubstring: clas superclass name asString with:  newSuper.

    clas withAllSubclasses asArray reversed  do:[:e | e removeFromSystem ].

    theClassesToInstall := ReadWriteStream on: newString.
    theClassesToInstall fileIn.!   !



!GsMoveClassView methods !

   
compileAllMethodsForNewClass: newClass fromOldClass: aModel

    aModel methodDictionary keys do:[:eKey|
        newClass
            compile: (aModel methodDictionary at: eKey) sourceString.
            Smalltalk
                logSource: (aModel methodDictionary at: eKey) sourceString
                forSelector: eKey
                inClass: newClass.].
    aModel class methodDictionary keys do:[:eKey|
        newClass class
            compile: (aModel class methodDictionary at: eKey) sourceString.
            Smalltalk
                logSource: (aModel class methodDictionary at: eKey) sourceString
                forSelector: eKey
                inClass: newClass class.].!    !



!GsMoveClassView methods !

   
duplicateSuperclassInstVars: aSuperClass in: aClass

    | myOC subclassOC |

    myOC := OrderedCollection new.
    subclassOC := Set new.

    aClass withAllSubclasses do:[:e |
        subclassOC  addAll: e instVarNames].

    aSuperClass allInstVarNames asOrderedCollection do:[:e |
        myOC addAll: (subclassOC asOrderedCollection select:[:eIn | eIn = e])].

    myOC isEmpty
        ifFalse:[
                MessageBox message: 'There are duplicate instance or class variables!!'.
                ^true].

    ^false!   !



!GsMethodParser class methods !

  
partNamesInArray: aSubstringArray

    | aCollection badOnes|
    aCollection := Set new.

    badOnes := ''';()'.
    1 to: aSubstringArray size
        do:[:e |
            ( (aSubstringArray at: e) = 'paneName:')
                ifTrue:[
                    aCollection add: ( (aSubstringArray at: e+1 ) reject: [ :c | badOnes includes: c ] ) ] ].

    ^aCollection asOrderedCollection!   !



!GsMethodParser class methods !

  
partNamesInClass: aClass

    | myArray aCollection |

    aCollection := Set new.
    (self relaventMethodsForClass: aClass)
        do:[:eachMethod |
            aCollection addAll: (self partNamesInMethod: eachMethod)].

   ^aCollection  asOrderedCollection!  !



!GsMethodParser class methods !

  
allSubViewPartNamesInClass: aClass

    | aCollection |

    aCollection := Set new.
    (self allSubViewNamesInClass: aClass)
        do:[:eachView |
            aCollection addAll: (self partNamesInClass: eachView)].
    ^aCollection asOrderedCollection!    !



!GsMethodParser class methods !

  
allSubViewNamesInClass: aClass

    | subViews aCollection |

    aCollection := Set new.
    subViews := Set new.
    subViews addAll: (self subViewNamesInClass: aClass).
    subViews add: aClass.
    subViews
        do:[:eachView |
            aCollection add: eachView.
            aCollection addAll: (self subViewNamesInClass: eachView)].

   ^aCollection  asOrderedCollection!    !



!GsMethodParser class methods !

  
partNamesInMethod: aMethod

    | aCollection |
    aCollection := Set new.
    aCollection addAll: (self partNamesInArray: (self arrayOfSubStringsForMethod: aMethod)).
    ^aCollection asOrderedCollection! !



!GsMethodParser class methods !

  
relaventMethodsForClass: aViewClass

    | aCollection |

    aCollection := Set new.
    (aViewClass methodDictionary at: 'createViews' asSymbol ifAbsent:[nil]) isNil
        ifFalse:[ aCollection add: (aViewClass methodDictionary at: 'createViews' asSymbol)].
    (aViewClass methodDictionary at: 'addSubpanes' asSymbol ifAbsent:[nil]) isNil
        ifFalse:[ aCollection add: (aViewClass methodDictionary at: 'addSubpanes' asSymbol)].

    ^aCollection asOrderedCollection!  !



!GsMethodParser class methods !

  
subViewNamesInClass: aClass

    | myArray aCollection |

    aCollection := Set new.
    (self relaventMethodsForClass: aClass)
        do:[:eachMethod |
            aCollection addAll: (self subViewNamesInMethod: eachMethod)].

   ^aCollection  asOrderedCollection!    !



!GsMethodParser class methods !

  
subViewNamesInMethod: aMethod

    | myArray aCollection |

    aCollection := Set new.
    myArray := self arrayOfSubStringsForMethod: aMethod.
    aCollection addAll: (self subViewNamesInArray: myArray).
   ^aCollection  asOrderedCollection!  !



!GsMethodParser class methods !

  
subViewNamesInArray: aSubstringArray

    | aCollection |
    aCollection := Set new.

    1 to: aSubstringArray size
        do:[:e |
            ( (aSubstringArray at: e) = 'new')
                ifTrue:[
                    ((aSubstringArray at: e - 1) asClass isClass)
                        ifTrue:[
                            aCollection add:  (aSubstringArray at: e - 1) asClass] ] ].

    ^aCollection asOrderedCollection!   !



!GsMethodParser class methods !

  
arrayOfSubStringsForMethod: aMethod

    ^aMethod sourceString asArrayOfSubstrings!   !



!GsMethodGeneratorSelectionView class methods !

  
newOn: aClass withView: aView

    | anOC |

    anOC := OrderedCollection new.

    aClass instVarNames asOrderedCollection
        do:[:each |
            anOC add: each.
            anOC add: each,':'].

    ^(self new)
        possibleVars: anOC;
        objectClass: aClass;
        parentView: aView;
        open;
        yourself.! !



!GsMethodGeneratorSelectionView class methods !

  
wbCreated

    ^true! !



!GsEntryFieldCompositePane methods !

 
ok: aPane

    "Callback for the #clicked event in the Button named 'okButton'.
     (Generated by WindowBuilder)"


       self event: #ok!  !



!GsEntryFieldCompositePane methods !

 
cancel: aPane

    "Callback for the #clicked event in the Button named 'cancelButton'.
     (Generated by WindowBuilder)"


    self event: #cancel! !



!GsEntryFieldCompositePane methods !

 
addSubpanes
    (self
        yourself;
            framingBlock: ( FramingParameters new iDUE: 585 @ 136; xC; yC; cRDU: (2 @ 134 rightBottom: 583 @ 2));
            addSubpane: (
                EntryField new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 585 @ 48; lDU: 0 r: #left; rDU: 585 r: #left; tDU: 0 r: #top; bDU: 48 r: #top; indent: 3 @ 4);
                    paneName: 'entryField';
                    startGroup;
                    yourself
            );
            addSubpane: (
                Button new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 146 @ 64; lDU: 247 r: #left; rDU: 393 r: #left; tDU: 64 r: #top; bDU: 128 r: #top);
                    paneName: 'okButton';
                    idOK;
                    startGroup;
                    when: #clicked perform: #ok:;
                    contents: 'Ok';
                    yourself
            );
            addSubpane: (
                Button new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 146 @ 64; lDU: 411 r: #left; rDU: 558 r: #left; tDU: 64 r: #top; bDU: 128 r: #top);
                    paneName: 'cancelButton';
                    idCancel;
                    startGroup;
                    when: #clicked perform: #cancel:;
                    contents: 'Cancel';
                    yourself
            );
        yourself
    ).!  !



!GsRenameClassView class methods !

   
wbCreated

    ^true! !



!GsRenameClassView class methods !

   
newOn: aModel parentView: aView

    ^self new
        model: aModel;
        parentView: aView;
        open;
        yourself.! !



!GsEntryFieldCompositePane class methods !

   
supportedEvents
        "Private - Answer the events supported by this subpane."
    ^super supportedEvents
        add: #ok;
        add: #cancel;
        yourself!  !



!GsEntryFieldCompositePane class methods !

   
wbCreated

    ^true! !



!GsPartNameListView methods !


partNameList: anObject

     (self paneNamed: 'partNameList') contents: anObject.

     ^(self paneNamed: 'partNameList') contents! !



!GsPartNameListView methods !


allPartNames: anObject

     allPartNames := anObject.
     self signalEvent: #allPartNames
          with: anObject.
     ^allPartNames!  !



!GsPartNameListView methods !


allPartNames

    allPartNames isNil
        ifTrue:[
            allPartNames := OrderedCollection new].

     ^allPartNames!    !



!GsPartNameListView methods !


createViews

     "WARNING!!  This method was automatically generated by
      WindowBuilder.  Code you add here which does not conform
      to the WindowBuilder API will probably be lost the next time
      you save your layout definition."

     | v |

    self addView: (
        v := self topPaneClass new
            owner: self;
            labelWithoutPrefix:  'New Window';
            noSmalltalkMenuBar;
            viewName: 'mainView';
            framingBlock: ( FramingParameters new iDUE: 731 @ 752; xC; yC; cRDU: (9 @ 744 rightBottom: 722 @ 46));
            pStyle: #(sysmenu sizable titlebar minimize maximize);
            when: #opened perform: #openedWidget:;
            addSubpane: (
                ListBox new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 640 @ 552; lDU: 37 r: #left; rDU: 37 r: #right; tDU: 32 r: #top; bDU: 114 r: #bottom);
                    paneName: 'partNameList';
                    startGroup;
                    when: #getContents perform: #partNameListGetContents:;
                    setPopupMenu: (
                        Menu new
                            title: '';
                            owner: self;
                            appendItem: 'Generate Getter' selector: #generateGetterClicked acceleratorString: '';
                            appendItem: 'Generate Setter' selector: #generateSetterClicked acceleratorString: ''
                    );
                    yourself
            );
            addSubpane: (
                Button new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 329 @ 64; lDU: 539 r: #right; rDU: 210 r: #right; tDU: 90 r: #bottom);
                    paneName: 'placeOnClipboardButton';
                    startGroup;
                    when: #clicked perform: #pasteOnClipoardButtonClicked:;
                    contents: 'Place On Clipboard';
                    yourself
            );
            addSubpane: (
                Button new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 128 @ 64; lDU: 165 r: #right; rDU: 37 r: #right; tDU: 90 r: #bottom);
                    paneName: 'closePushButton';
                    startGroup;
                    when: #clicked perform: #closePushButtonCicked:;
                    contents: 'Close';
                    yourself
            );
        yourself
    ).!   !



!GsPartNameListView methods !


partNameListGetContents: aPane

    "Callback for the #getContents event in the ListBox named 'partNameList'.
     (Generated by WindowBuilder)"

     ^(self paneNamed: 'partNameList') contents: self allPartNames!  !



!GsPartNameListView methods !


partNameList

     ^(self paneNamed: 'partNameList') contents!    !



!GsPartNameListView methods !


viewClass: anObject

     viewClass := anObject.
     self signalEvent: #viewClass
          with: anObject.
     ^viewClass!  !



!GsPartNameListView methods !


openedWidget: aPane

    "Callback for the #opened event in the TopPane 'mainView'.
     (Generated by WindowBuilder)"

    self label: 'Subpart Builder For',self viewClass asString.!    !



!GsPartNameListView methods !


generateGetterClicked

    "Callback for the menu item titled 'Generate Getter'.
     (Generated by WindowBuilder)"

     GsPartNameGenerator generateMethodForPartGetter: (self paneNamed: 'partNameList') selectedItem
        forClass: self viewClass.!   !



!GsPartNameListView methods !


closePushButtonCicked: aPane

    "Callback for the #clicked event in the Button named 'closePushButton'.
     (Generated by WindowBuilder)"

     self closeWindow!   !



!GsPartNameListView methods !


viewClass

     ^viewClass!   !



!GsPartNameListView methods !


pasteOnClipoardButtonClicked: aPane

    "Callback for the #clicked event in the Button named 'placeOnClipboardButton'.
     (Generated by WindowBuilder)"

    (self paneNamed: 'partNameList') selectedItem isNil
        ifFalse:[
            GsPartNameGenerator partNameOnClipBoard:  (self paneNamed: 'partNameList') selectedItem]!  !



!GsPartNameListView methods !


generateSetterClicked

    "Callback for the menu item titled 'Generate Setter'.
     (Generated by WindowBuilder)"

     GsPartNameGenerator generateMethodForPartSetter: (self paneNamed: 'partNameList') selectedItem
        forClass: self viewClass.!   !



!String methods !


asStream
        "Answer a ReadWriteStream on the receiver."
    ^ReadWriteStream on: self!   !



!String methods !


displayAt: aPoint
        "Output the receiver directly onto
         the display screen at aPoint."
    self displayAt: aPoint font: SysFont!   !



!String methods !


fileExtension
        "Answer a three character String that
         follows the receiver's first period
         character (for DOS file names)."
    | answer stream pos f|
    stream := (ReadStream on: self trimBlanks).
    f:=true.
    [f] whileTrue:[pos:=stream position.f:=stream  skipTo: $.].
    pos = 1 ifTrue:[^'   '].
    stream position:pos.
    answer:=stream upTo: $..
    answer size > 3
        ifTrue: [self error: 'file extension too long'].
    ^(answer , (String with: $  with: $  with: $ ))
        copyFrom: 1 to: 3! !



!String methods !


asLowerCase
        "Answer a String containing the
         receiver with alphabetic
         characters in lower case."
    | answer size index aCharacter |
    size := self size.
    answer := String new: size.
    index := 1.
    [index <= size]
        whileTrue: [
            (aCharacter := self at: index) isUpperCase
                ifTrue: [aCharacter := aCharacter asLowerCase].
            answer at: index put: aCharacter.
            index := index + 1].
    ^answer! !



!String methods !


asMessage
    "Added by OSI - Converts a piece of code into a message selector"
    | array semiArray result |

    self isEmpty ifTrue:[ ^nil ].
    #addedByOSI.
    array := self asArrayOfSubstrings.
    semiArray := array select: [ :s |
        (s last == $: and:
        [ s size > 1 and:
        [(s at: s size - 1) ~= $$ ]])].
    semiArray size > 0
        ifTrue: [
            result := ''.
            semiArray do: [ :s | result := result, s trimBlanks ]]
        ifFalse: [
            result := (ReadStream on: array first) nextWord.
            result isNil ifTrue: [ result := array first ].
            (result first isUpperCase and: [ array size > 1 ])
                ifTrue: [ result := (ReadStream on: (array at: 2)) nextWord ]].
    ^result asSymbol! !



!String methods !


asAsciiZ
        "Answer a new String containing all the
         characters of the receiver followed by
         the character of ASCII value zero."
    ^self, (String with: 0 asCharacter)!  !



!String methods !


equals: aString
        "Answer true if the receiver is equal to
         the argument aString, else answer false.
         Note that the comparison is case sensitive."
    <primitive: 55>
    ^self primitiveFailed!    !



!String methods !


asProperNoun
    "Added by OSI. Answer a String containing the receiver
     with alphabetic characters in mixed proper case."
    | answer size index aCharacter |
    #addedByOSI.
    size := self size.
    answer := String new: size.
    index := 1.
    [index <= size]
        whileTrue: [
            aCharacter := self at: index.
            (index == 1 or: [
            (self at: index - 1) isWhitespace and: [
            aCharacter isLowerCase ]])
                ifTrue: [aCharacter := aCharacter asUpperCase].
            answer at: index put: aCharacter.
            index := index + 1].
    ^answer!   !



!String methods !


mnemonicChar

    "Added by OSI.  Scan for the mnenomic character (&), and
     answer the character following it.  If no mnemonic, answer nil."

    | index |
    #addedByOSI.
    index := (self indexOf: $& ifAbsent: [ self size ]) + 1.
    index > self size ifTrue: [
        ^nil
    ].

    ^(self at: index) asUpperCase!   !



!String methods !


asFloat
        "Answer an instance of Float which is a conversion self;
         self is expected to be a sequence of
         the form [(+|-)] [digits] [decSep [digits] ] [(E|e) [(+|-) digits]]."
    ^Float fromString: self!  !



!String methods !


asDate
        "Answer a Date representing the date
         described by the receiver.  The receiver
         must contain first the day number then
         the month name and then the year
         separated by blanks."
    ^Date fromString: self!    !



!String methods !


= aString
        "Answer true if the receiver is equal to
         aString, else answer false.  The comparison
         is case sensitive."
    <primitive: 55>
    ^self primitiveFailed!    !



!String methods !


asParameter
        "Answer the receiver in a form suitable for passing
         as a parameter to the host system procedure call."
    ^self asAsciiZ!  !



!String methods !


asArrayOfSubstrings
        "Answer an array of substrings from the
         receiver.  The receiver is divided into
         substrings at the occurrences of one or
         more space characters."
    | aStream answer index|
    answer := OrderedCollection new.
    aStream := ReadStream on: self.
    [aStream atEnd]
        whileFalse: [
            [aStream atEnd ifTrue: [^answer asArray].
             aStream peek isWhitespace not]
                whileFalse: [aStream next].
            index := aStream position + 1.
            [aStream atEnd or: [aStream peek isWhitespace]]
                whileFalse: [aStream next].
            answer add:
                (self copyFrom: index to: aStream position)].
    ^answer asArray! !



!String methods !


fileName
        "Answer the characters of the receiver string up
         to the first period character.  Report an error
         if the resulting string is greater than eight or
         less than one character (for DOS file names)."
    | answer |
    answer := self trimBlanks.
    (answer = (String with: $.) or:
     [answer = (String with: $. with: $.)])
        ifFalse: [
            answer := (ReadStream on: answer)
                upTo: $..
            answer size = 0
                ifTrue: [self error: 'file name missing'].
            answer size > 8
                ifTrue: [self error: 'file name too long']].
    ^ answer! !



!String methods !


asArrayOfSubstringsDelimitedByWhiteSpace
      "Answer an array of substrings from the receiver.  The receiver is divided into
       substrings at the occurrences of white space characters (space cr lf tab)"

   "KSC 08-16-89: SSA -- Added Method."

   | aStream answer index whiteSpace |

   whiteSpace := #(32 13 10 9).
   answer := OrderedCollection new.
   aStream := ReadStream on: self.

   [aStream atEnd] whileFalse: [

      [aStream atEnd ifTrue: [^ answer asArray].
       whiteSpace includes: aStream peek asciiValue]
         whileTrue: [aStream next].

      index := aStream position + 1.
      [aStream atEnd or: [whiteSpace includes: aStream peek asciiValue]]
         whileFalse: [aStream next].

      answer add: (self copyFrom: index to: aStream position)].

   ^ answer asArray!   !



!String methods !


asQuotedString

    "Added by OSI"

    | stream |
    #addedByOSI.
    stream := WriteStream on: String new.
    self printOn: stream.
    ^stream contents!   !



!String methods !


containsDBCharacter
        "Answer whether the receiver contains
         any double-byte characters.
         Base support for NLS/DBCS functionality. "
    ^false!  !



!String methods !


asNormalizedString
        "Interpret the receiver as a mixed string encoding
         using the lead byte flags of the current national language.
         Answer the equivalent DoubleByteString if the receiver
         contains any double-byte characters.  Answer the
         receiver if it only contains single byte characters.
         Base support for NLS/DBCS functionality."
    ^self! !



!String methods !


trimNullTerminator
        "Answer a String containing the receiver string
         with anything after the null terminator removed."
    | nullTermIndex |
    (nullTermIndex := self indexOf:0 asCharacter) > 0
        ifTrue: [^ self copyFrom:1 to: nullTermIndex - 1]
        ifFalse: [^ self]!    !



!String methods !


trimBlanks
        "Answer a String containing the receiver string
         with leading and trailing blanks removed."
    | nonBlank index aStream |
    nonBlank := false.
    aStream := ReadStream on: self.
    [aStream atEnd or: [nonBlank := aStream next isWhitespace not]]
        whileFalse:[].
    nonBlank
        ifTrue: [index := aStream position]
        ifFalse: [^String new: 0].
    aStream position: self size - 1.
    [aStream next isWhitespace not]
        whileFalse: [aStream skip: -2].
    ^self copyFrom: index to: aStream position!  !



!String methods !


outputToPrinter
        "Answer the receiver.  Output the receiver string to
         the printer."
    Printer print: self font: nil title: nil!    !



!String methods !


hash
        "Answer the integer hash
         value for the receiver."
    | theHash index |
    <primitive: 107>
    index := self size.
    theHash := 0.
    [index < 1]
        whileFalse: [
            theHash :=
                (theHash * 61 + (self at: index) asciiValue)
                    bitAnd: 16r3FFF.
            index := index - 1].
    ^ theHash bitAnd: 16r3FFF!    !



!String methods !


> aString
        "Answer true if the receiver is after
         aString, else answer false.  The comparison
         is not case sensitive."
    ^(self <= aString) not!   !



!String methods !


replaceFrom: start to: stop withObject: aCharacter
        "Replace the characters of the receiver
         at index positions start through stop
         with aCharacter.  Answer aCharacter."
    <primitive: 106>
    ^super
        replaceFrom: start
        to: stop
        withObject: aCharacter!    !



!String methods !


zapAllCharsMatching: aString
      "Answer all the String which results from stripping from myself all characters
       contained in aString."

   " '1k2k3k4kk5;' zapAllCharsMatching: 'k;' "

   "KSC 01-24-92: ECS -- Addapted from SSA's (?) original method."

   | stream c |

   stream := ReadWriteStream on: ''.

   1 to: self size do: [:i |
      (aString includes: (c := self at: i)) ifFalse: [stream nextPut: c]].

   ^ stream contents!   !



!String methods !


replace: count with: aCollection
        "Answer the receiver.  Replace count number of
         characters in the beginning of the receiver
         from the same number of characters in the
         beginning of aCollection.  aCollection can
         be a WinAddress and count can be a
         large integer."
    WinAddress
        copyFrom: aCollection
        to: self
        count: count!  !



!String methods !


stripMnemonic

    "Added by OSI"
    #addedByOSI.
    ^self select: [ :c | (c = $~) not & (c = $&) not ]!  !



!String methods !


replaceFrom: start to: stop withAddress: anAddress startingAt: int
        "Replace the characters of the receiver at index
         positions start through stop with consecutive
         characters of the contents of anAddress beginning at index
         position repStart.  Answer the receiver.  anAddress
         can be a host system memory address."
    ^self replaceFrom: start
        to: stop
        with: anAddress
        startingAt: int!  !



!String methods !


basicAt: anInteger put: aCharacter
        "Answer aCharacter.  At index position
         anInteger in the receiver put the
         character aCharacter."
    <primitive: 64>
    self checkIndex: anInteger.
    self checkCharacter: aCharacter.
    ^self primitiveFailed! !



!String methods !


>= aString
        "Answer true if the receiver is after or equal to
         aString in the current sort sequence, else answer false.
         The comparison is not case sensitive."
    aString isString
        ifFalse: [ ^self error: 'invalid string argument' ].
    ^aString <= self!    !



!String methods !


isString
        "Answer true if receiver is an instance of class
         String, else answer false."
    ^true!    !



!String methods !


replaceFrom: start
    to: stop
    with: aString
    startingAt: repStart
        "Replace the characters of the receiver at index
         positions start through stop with consecutive
         characters of aString beginning at index
         position repStart.  Answer the receiver."
    | index1 index2 |
    <primitive: 105>
    (aString class isBytes)
        ifFalse: [
            ^super
                replaceFrom: start
                to: stop
                with: aString
                startingAt: repStart].
    (self == aString and: [repStart < start])
        ifTrue: [ "do backward move for same object"
            index2 := repStart + stop - start.
            index1 := stop.
            [start <= index1]
                whileTrue: [
                self
                    at: index1
                    put: (aString at: index2) asCharacter.
                index1 := index1 - 1.
                index2 := index2 - 1].
            ^self].
    "do forward move"
    index2 := repStart.
    index1 := start.
    [index1 <= stop]
        whileTrue: [
            self
                at: index1
                put: (aString at: index2) asCharacter.
            index1 := index1 + 1.
            index2 := index2 + 1]!   !



!String methods !


size
        "Answer the size of the receiver string."
    <primitive: 62>!   !



!String methods !


displayAt: aPoint font: aFont
        "Output the receiver onto the display screen
         in white at aPoint with font aFont."
    | oldFont |
    oldFont := Display pen font.
    Display pen
        font: aFont;
        displayText: self at: aPoint.
    Display pen font: oldFont! !



!String methods !


<= aString
        "Answer true if the receiver is before
         or equal to aString, else answer false.
         The comparison is not case sensitive."
    <primitive: 56>
    ^self primitiveFailed!  !



!String methods !


asSymbol
        "Answer a symbol whose characters
         are the same as the receiver string."
    ^Symbol intern: self!  !



!String methods !


asInteger
        "Answer the integer conversion of the receiver;
         the receiver is expected to be a sequence of
         digits with optional leading minus sign."
    | answer char |
    answer := 0.
    self size = 0 ifTrue: [^answer].
    (self at: 1) = $-
        ifTrue: [
            ^(self copyFrom: 2 to: self size)
                asInteger negated].
    1 to: self size do: [ :index |
        (char := self at: index) isDigit
            ifFalse: [^answer].
        answer := answer * 10 + char digitValue].
    ^answer!    !



!String methods !


stripControlCharacters
   "Answer a String containing the receiver string with all characters less than ASCII
    32 removed."

   "KSC 12-31-89: SSA -- Added method."

   | char  resultStream  index aStream |

   aStream := ReadStream on: self.
   resultStream := WriteStream on:''.

   [aStream atEnd] whileFalse: [
      char := aStream next.
      char asciiValue < 32 ifFalse: [resultStream nextPut: char]].

   ^ resultStream contents!    !



!String methods !


edit
        "Open a workspace window with the
         receiver string as the contents."
    TextWindow new
        label: 'Workspace';
        openOn: self.!    !



!String methods !


asByteArray
        "Added by OSI - Answer a ByteArray whose contents are the
         bytes of the receiver."
    #addedByOSI.
    ^(ByteArray new: self size) replace: self size with: self.! !



!String methods !


asClass

    ^Smalltalk at: self asSymbol ifAbsent:[nil]! !



!String methods !


basicAt: anInteger
        "Answer the character at position
         anInteger in the receiver string."
    <primitive: 63>
    self checkIndex: anInteger.
    ^self primitiveFailed!    !



!String methods !


asString
        "Answer the string representing the
         receiver (the receiver itself)."
    ^self!    !



!String methods !


storeOn: aStream
        "Append the ASCII representation of the
         receiver to aStream from which the
         receiver can be reinstantiated."
    self printOn: aStream!   !



!String methods !


printOn: aStream
        "Append the receiver as a quoted string
         to aStream doubling all internal single
         quote characters."
    aStream nextPut: $'.
    self do: [ :character |
        aStream nextPut: character.
        character = $'
            ifTrue: [aStream nextPut: character]].
    aStream nextPut: $'!  !



!String methods !


equalsIgnoreCase: aString
        "Answer true if the reciever is equal to
         aString, anse answer false.
         The compairision is not case sensitive."
    ^self <= aString and: [(self < aString) not]! !



!String methods !


formatOn: wStream leftMargin: leftMargin lineLength: lineLength
        "Output on wStream the result of word wrapping myself to the given line
         length, in characters.  Each line is 'tabbed' over by leftMargin characters.
         The line length does not include the left margin."

    "KSC 06-02-91: ECS -- Added method."

    | rStream aUnit unitWidth currentLength lastWasCr marginString printUnit |

    "Initialze control variables, cook up a read stream on me."
    rStream := ReadStream on: self.
    currentLength := 0.
    lastWasCr := false.
    marginString := String new: leftMargin.
    1 to: leftMargin do: [:i | marginString at: i put: Space].
    wStream nextPutAll: marginString.

    "Work wrap until I run out of words."
    [rStream atEnd] whileFalse: [

        "Get next word.  Find out how long it is."
        aUnit := rStream nextTextUnit.
        unitWidth := aUnit size.

        "Check for end-of-line in input stream."
        (aUnit at: 1) == Cr
            ifTrue: ["If this is the second Cr in a row, force an end-of-line and start a new
                          paragraph on the output stream."
                         lastWasCr
                            ifTrue: ["Yep, it's new paragraph time."
                                        wStream cr; cr.
                                        wStream nextPutAll: marginString.
                                        lastWasCr := false.
                                        currentLength := 0]
                            ifFalse: [lastWasCr := true]]
            ifFalse: ["Normal word or block of spaces.  If lastWasCr, then we've pasted
                          two lines together.  Insert a blank so they don't run together."
                          printUnit := true.
                          lastWasCr
                            ifTrue: [wStream nextPut: Space.
                                        currentLength := currentLength + 1.
                                        (aUnit at: 1) == Space ifTrue: [printUnit := false].
                                        lastWasCr := false].

                          printUnit
                            ifTrue: ["See if this will fit in the current line.  If not start a new one."
                                        currentLength := currentLength + unitWidth.

                                         currentLength <= lineLength
                                            ifTrue: [wStream nextPutAll: aUnit]
                                            ifFalse: ["Time to start a new line and put the new word there.  BUT!!!!
                                                          not if the new word is nothing but spaces.  If this is the case,
                                                          dump them on the current line before starting a new one."
                                                          (aUnit at: 1) == Space
                                                            ifTrue: [wStream nextPutAll: aUnit.
                                                                        wStream cr.
                                                                        wStream nextPutAll: marginString.
                                                                        currentLength := 0]
                                                            ifFalse: [wStream cr.
                                                                          wStream nextPutAll: marginString.
                                                                          wStream nextPutAll: aUnit.
                                                                          currentLength := unitWidth]]]]]! !



!String methods !


hasContent

    "Added by OSI"

    (self isEmpty) ifTrue: [
        #addedByOSI.
        ^false
    ].

    self do: [ :aChar |
        (aChar == $ ) not ifTrue: [
            ^true
        ].
    ].

    ^false!    !



!String methods !


checkCharacter: aCharacter
        "Private - Report an error if the argument
         aCharacter is not an instance of class Character."
    (aCharacter isCharacter)
        ifFalse: [
            ^self error: 'can''t hold '
                , aCharacter class name,'''s']! !



!String methods !


beginsWith: aString

    "Added by OSI"
    #addedByOSI.
    ^(self size >= aString size) and: [
        (1 to: aString size)
            detect: [:i | (self at: i) ~~ (aString at: i)]
            ifNone: [^true].
        false]!   !



!String methods !


at: anInteger put: aCharacter
        "Answer aCharacter.  At index position
         anInteger in the receiver put the
         character aCharacter."
    <primitive: 64>
    self checkIndex: anInteger.
    self checkCharacter: aCharacter.
    ^self primitiveFailed!  !



!String methods !


< aString
        "Answer true if the receiver is before
         aString, else answer false.  The comparison
         is not case sensitive."
    ^(aString <= self) not!  !



!String methods !


asMixedString
        "Answer the mixed-string encoding
        representing the receiver.
        Base support for NLS/DBCS functionality."
    ^self! !



!String methods !


asCompactString
        " Answer the most compact string containing the
         characters of the receiver.  
         Base support for NLS/DBCS functionality."
    ^self!    !



!String methods !


withCrs
        "Answer the receiver string where each
         occurrence of the character \ has been
         replaced with a line-feed character."
    1 to: self size do: [ :index |
        (self at: index) = $\
            ifTrue: [self at: index put: Lf]]! !



!String methods !


replaceSubstring: s with: rs

    | theIndex myStream oldStream |

    s = rs ifTrue:[^self].
    oldStream := ReadWriteStream on: self.
    myStream := ReadWriteStream on: ''.
    [(theIndex := (oldStream reset; indexOf: s)) ~= 0]
        whileTrue:[
            myStream := ReadWriteStream on: ''.
            oldStream reset.
            theIndex = 1
                ifTrue:[myStream nextPutAll: '']
                ifFalse:[myStream nextPutAll: (oldStream copyFrom: 1to: (theIndex - 1 ))].
            myStream nextPutAll: rs.
            myStream nextPutAll: (oldStream copyFrom: (theIndex + s size) to: oldStream readLimit).
            oldStream := ReadWriteStream on: myStream contents.
            oldStream reset.].

    myStream reset.
    ^myStream contents!  !



!String methods !


asUpperCase
        "Answer a String containing the
         receiver with alphabetic
         characters in upper case."
    | answer size index aCharacter |
    size := self size.
    answer := String new: size.
    index := 1.
    [index <= size]
        whileTrue: [
            (aCharacter := self at: index) isLowerCase
                ifTrue: [aCharacter := aCharacter asUpperCase].
             answer at: index put: aCharacter.
            index := index + 1].
    ^answer!    !



!String methods !


upTo: aCharacter

    "Added by OSI - answer the string up to the given character,
     or the entire string if the character isn't found"

    | s |
    #addedByOSI.
    s := ReadStream on: self.
    ^s upTo: aCharacter!   !



!String methods !


at: anInteger
        "Answer the character at position
         anInteger in the receiver string."
    <primitive: 63>
    self checkIndex: anInteger.
    ^self primitiveFailed! !



!GsClassHierarchyRouter class methods !

  
gsOpenMoveViewFor: aClass parentView: aView

    ^GsMoveClassView openOn: aClass parentView: aView.!  !



!GsClassHierarchyRouter class methods !

  
gsOpenPartNamesListViewOn: aModel

    GsPartNameListView newOn: aModel!  !



!GsClassHierarchyRouter class methods !

  
gsOpenGenerationSelectionWindowOn: aClass withView: aView

    ^GsMethodGeneratorSelectionView newOn: aClass withView: aView! !



!GsClassHierarchyRouter class methods !

  
gsOpenRenameClassViewFor: aClass parentView: aView

    ^GsRenameClassView newOn: aClass parentView: aView.!  !



!GsViewManager methods !

 
parentView: anObject

     parentView := anObject.
     self signalEvent: #parentView
          with: anObject.
     ^parentView!  !



!GsViewManager methods !

 
parentView

     ^parentView! !



!GsViewManager methods !

 
allComponents

    | aCollection partNames |
    aCollection := OrderedCollection new.
    partNames := (GsMethodParser allSubViewPartNamesInClass:  self class).

    partNames do:[:eachPartName |
        aCollection add: (self paneNamed: eachPartName)].

    ^aCollection!  !



!GsViewManager methods !

 
model: anObject

     model := anObject.
     self signalEvent: #model
          with: anObject.
     ^model!  !



!GsViewManager methods !

 
model

     ^model!   !



!GsPartNameListView class methods !

  
wbCreated

    ^true! !



!GsPartNameListView class methods !

  
newOn: aViewClass

    ^(self new)
            allPartNames: (GsPartNameGenerator allSubViewPartNamesInClass: aViewClass);
            viewClass: aViewClass;
            open;
            yourself.!    !



!ClassHierarchyBrowser methods !

 
findClass
        "Private - Prompt for a class to search for, and position at
         that point in the hierarchy."
    | className class supers blanks result |
    self textModified ifTrue: [^self].
    className := Prompter prompt: 'Name of class:' default: ''.
    (className isNil or: [className isEmpty])
        ifTrue: [ ^ self ].
    className := className asSymbol.
    class := Smalltalk at: className ifAbsent: [
        ^MessageBox message: 'Class "', className,
                        '" not found in Smalltalk.' ].
    (class isBehavior) ifFalse: [
        ^MessageBox message: '"', className,
                        '" is not a class.' ].
    CursorManager execute change.
    supers := (Array with: class), class allSuperclasses.
    blanks := 0.
    1 to: supers size do: [ :i |
        (originalClasses includes: (supers at: i))
           ifTrue: [ blanks := i ]].
    blanks = 0 ifTrue: [
        CursorManager normal change.
        ^MessageBox message: 'Class "', className,
                        '" not found in this browser.' ].
    supers do: [ :cl |
        hiddenClasses remove: cl ifAbsent: []].
    self update: originalClasses.
    methodSelectedLast := false.
    selectedMethod := nil.
    selectedInstVar := nil.
    selectedClass := class.
    self changed: #hierarchy:
        with: #restoreSelected:
        with: (((String new: ((blanks - 1 max: 0) * 2)) atAllPut: $ ),
            class name).
    self enableClassesMenu.
    self disableMethodsMenu.
    self
        changed: #instanceVars: ;
        changed: #selectors: ;
        changed: #text:.
    CursorManager normal change.!   !



!ClassHierarchyBrowser methods !

 
hideShow: aPane
        "Private - Change the hide/show state of the hierarchy pane."
    self hideShow!  !



!ClassHierarchyBrowser methods !

 
label
        "Private - Answer the window label."
    ^'Class Hierarchy Browser'!    !



!ClassHierarchyBrowser methods !

 
compile: aString 
    notifying: aDispatcher 
    in: aClass 
        "Private - Accept aString as an updated 
         method and compile it.  Notify aDispatcher 
         if the compiler detects errors." 
    | answer oldCursor | 
    oldCursor := Cursor. 
    CursorManager execute change. 
    answer := aClass 
        compile: aString 
        notifying: aDispatcher. 
    oldCursor change. 
    ^ answer!    !



!ClassHierarchyBrowser methods !

 
update: aCollection
       "Private - Recompute the list of
        browsed classes from aCollection."
    originalClasses := aCollection.
    browsedClasses := OrderedCollection new: 120.
    self addClasses: aCollection at: 0!   !



!ClassHierarchyBrowser methods !

 
openGenerationSelectionWindow

    GsMethodGenerator openGenerationSelectionWindowOn: self selectedClass withView: self.! !



!ClassHierarchyBrowser methods !

 
accept: textPane
        "Private - Accept the contents of textPane
         as an updated method
         or class specification and compile it."
    | result aClass aString |
    aString := textPane contents.
    methodSelectedLast
        ifFalse: [
            ^textPane modified: (
                self acceptClass: aString from: textPane)].
    aClass := instanceSelectedLast
        ifTrue: [selectedClass]
        ifFalse: [selectedClass class].
    result := self compile: aString
        notifying: textPane
        in: aClass.
    result isNil
        ifTrue: [textPane modified: true]
        ifFalse: [
            Smalltalk
                logSource: aString
                forSelector: result key
                inClass: aClass.
            result key == selectedMethod
                ifFalse: [
                    selectedMethod := result key.
                    self
                        changed: #selectors:
                            with: #restoreSelected:
                            with: selectedMethod;
                        enableMethodsMenu].
            textPane modified: false]!   !



!ClassHierarchyBrowser methods !

 
classButton: aButton
        "Private - Change the state of the browser
         so that class messages are selected."
    self textModified ifTrue: [
        self changed: 'class' with: instanceSelectedLast not.
        self changed: 'instance' with: instanceSelectedLast.
        ^self].
    instanceSelectedLast := methodSelectedLast := false.
    selectedInstVar := nil.
    self disableMethodsMenu.
    self
        changed: #instanceVars: ;
        changed: #selectors: ;
        changed: #text:! !



!ClassHierarchyBrowser methods !

 
addClasses: aCollection at: anInteger
       "Private - Add aCollection of classes to
        browsedClasses, each preceded by anInteger
        number of spaces.  anInteger indicates the
        level in the hierarchy."
    (aCollection asSortedCollection: Class sortBlock)
        do: [ :class |
            class symbol trimBlanks isEmpty
                ifFalse: [
                    browsedClasses add:
                        ((String new: anInteger * 2) atAllPut: $ )
                            , class symbol.
                    (hiddenClasses includes: class)
                        ifTrue: [
                            browsedClasses add:
                                browsedClasses
                                    removeLast, '...']
                        ifFalse: [
                            self
                                addClasses: class subclasses
                                at: anInteger + 1]]]!  !



!ClassHierarchyBrowser methods !

 
hierarchy: hierarchyPane
        "Private - Set the indented list of
         classes, an OrderedCollection of strings."

   hierarchyPane contents: browsedClasses!    !



!ClassHierarchyBrowser methods !

 
gsImplementors


        GsImplementorsView open.!   !



!ClassHierarchyBrowser methods !

 
assigned
        "Private - The user chose the Assigned menu item."
    assigned := true.
    used := false.
    self checkInstVarMenu.
    self changed: #selectors:! !



!ClassHierarchyBrowser methods !

 
gsGeneratePartNames

    GsClassHierarchyRouter gsOpenPartNamesListViewOn: self selectedClass.!   !



!ClassHierarchyBrowser methods !

 
initWindowSize
        "Private - Answer the initial
         window extent."
    ^Display width * 7 // 10 @
        (Display height * 9 // 10)!    !



!ClassHierarchyBrowser methods !

 
browse
        "Private - Open a ClassBrowser
         on the selected class."
    selectedClass isNil
        ifFalse: [selectedClass edit]!   !



!ClassHierarchyBrowser methods !

 
checkMenuForInstanceVariable
        "Private - Check the appropriate item in the instance
         variables menu when an instance variable is selected."
    | menu |
    menu := (self menuTitled: '&Variables').
    menu
        enableItem: #assigned;
        enableItem: #used.
    self checkInstVarMenu.! !



!ClassHierarchyBrowser methods !

 
disableMethodsMenu
        "Private - Disable the methods menu."
    (self menuTitled: '&Methods')
        disableItem: #removeSelector;
        disableItem: #senders;
        disableItem: #implementors;
        disableItem: #messages;
        disableItem: #localSenders;
        disableItem: #localImplementors;
        disableItem: #fileOutMethod.
    selectedClass isNil
        ifTrue: [(self menuTitled: '&Methods')
            disableItem: #newMethod]
        ifFalse: [(self menuTitled: '&Methods')
            enableItem: #newMethod]!    !



!ClassHierarchyBrowser methods !

 
hierarchySearch: aChar class: class index: index in: aPane
        "Private - Search for aChar matching subclasses of
         hidden class in aPane."
    | i |
    i := index.
    class allSubclasses do: [:each |
        i := i + 1.
        (each name at: 1) = aChar
            ifTrue: [
                selectedClass := class.
                self hideShow.
                aPane selection: i.
                ^self]].
    ^nil!    !



!ClassHierarchyBrowser methods !

 
hierarchySelected: hierarchyPane
        "Private - Display the selectors for the
         selected class in the selector list pane."
    | string aClass hidden |
    string := hierarchyPane selectedItem.
    hidden := false.
    string last == $.
        ifTrue: [
            hidden := true.
            string := string copyFrom: 1
                to: string size - 3].
    aClass := Smalltalk
        at: string trimBlanks asSymbol
        ifAbsent: [
            MessageBox message: 'non-existent class'.
            self update.
            ^self].
    methodSelectedLast := false.
    selectedMethod := nil.
    selectedInstVar := nil.
    selectedClass := aClass.
    self enableClassesMenu.
    self fixHideShowItem: hidden.
    self disableMethodsMenu.
    self
        changed: #selectors: ;
        changed: #instanceVars: ;
        changed: #text:.!   !



!ClassHierarchyBrowser methods !

 
senders
        "Private - Pop-up a window with the
         senders of the selected method."
    selectedMethod isNil
        ifFalse: [Smalltalk sendersOf: selectedMethod]!  !



!ClassHierarchyBrowser methods !

 
selectedClass

    "Added by OSI"
    #addedByOSI.
    ^selectedClass!  !



!ClassHierarchyBrowser methods !

 
hierarchyCharInput: aPane
        "Private - A character is typed, search for the matching
         class."
    | char |
    char := aPane characterTyped asUpperCase.
    CurrentEvents add: (Message new
        receiver: self
        selector: #hierarchySearchFor:in:
        arguments: (Array with: char with: aPane)).
    ^1!    !



!ClassHierarchyBrowser methods !

 
hierarchy
        "Private - Answer the indented list of
         classes, an OrderedCollection of strings."
    ^browsedClasses!    !



!ClassHierarchyBrowser methods !

 
checkMenuForClassVariable
        "Private - Check the appropriate item in the instance
         variables menu when a class variable is selected."
    | menu |
    menu := (self menuTitled: '&Variables').
    menu
        uncheckItem: #assigned;
        uncheckItem: #used;
        disableItem: #assigned;
        disableItem: #used;
        checkItem: #bothInstVars.! !



!ClassHierarchyBrowser methods !

 
fileOutWithSubclasses
        "Private - Write the source for the selected class
         as well as its subclasses in chunk file format to
         a file named with the class
         name reduced to 8 characters, extension 'cls'."
    | file |
    selectedClass isNil
        ifTrue: [^self].
    file := (FileDialog new
        saveTitle: 'File out ', selectedClass name, ' class and its subclasses'
        fileName: (
            File
                fileName: selectedClass name
                extension: 'cls')) file.
    file isNil ifTrue: [^self].
    CursorManager execute change.
    file := File newFile: file.
    selectedClass withAllSubclasses do: [:c |
        c fileOutOn: file.
        file nextChunkPut: String new.
        (ClassReader forClass: c class) fileOutOn: file.
        (ClassReader forClass: c) fileOutOn: file].
    file close.
    CursorManager normal change.!  !



!ClassHierarchyBrowser methods !

 
selector: selectorPane
		"Private - Display the selected
		 method in the text pane."
	selectedMethod := selectorPane isNil
		ifTrue: [nil]
		ifFalse: [selectorPane selectedItem].
	methodSelectedLast := true.
	self changed: #text:.
	self enableMethodsMenu.
	(((selectedInstVar notNil) and: [selectedMethod notNil]) and: [assigned | used]) ifTrue: [
		self changed: #text: with: #searchFor: with: selectedInstVar]! !



!ClassHierarchyBrowser methods !

 
gsGenerateMethods

    GsClassHierarchyRouter gsOpenGenerationSelectionWindowOn: self selectedClass withView: self.!  !



!ClassHierarchyBrowser methods !

 
update
		"Private - Recompute the browsed
		 classes and display them."
	self textModified ifTrue: [^self].
	CursorManager execute changeFor: [
		selectedMethod := nil.
		methodSelectedLast := false.
		self update: originalClasses.
		self changed: #hierarchy:.
		self disableClassesMenu.
		self disableMethodsMenu.
		self
			changed: #selectors: ;
			changed: #text: ;
			changed: #instanceVars:].

	selectedClass isNil
		ifTrue: [^self].
	1 to: browsedClasses size do: [:i |
		(selectedClass name = (((browsedClasses at: i) trimBlanks) copyWithout: $.))
			ifTrue: [
				(self paneAt: #hierarchy:) selection: i.
				self hierarchySelected: (self paneAt: #hierarchy:).
				^self]]!    !



!ClassHierarchyBrowser methods !

 
removeSubClass
        "Private - Delete the selected class."
    | classAssoc methods newName subclassType answer |
    selectedClass isNil
        ifTrue: [^nil].
    (MessageBox confirm: 'Delete Class "', selectedClass name, '"?')
        ifFalse: [^nil].
    CursorManager execute change.
    classAssoc := Smalltalk associationAt: selectedClass name asSymbol.
    methods := OrderedCollection new.
    Smalltalk rootClasses do:[:aClass|
        methods := methods, (aClass sendersOf: classAssoc)].
    CursorManager normal change.
    (methods size > 0)
        ifTrue: [
            MethodBrowser new
                label: 'Senders of ', classAssoc printString;
                literal: classAssoc;
                openOn: methods.
            (MessageBox confirm:
                    'There are methods which reference class "',
                    selectedClass name,
                    '".  Do you still wish to delete it?')
                ifFalse: [^nil]].
    CursorManager execute change.
    selectedClass removeFromSystem.
    selectedMethod := nil.
    methodSelectedLast := false.
    self update: originalClasses.
    self changed: #hierarchy:
        with: #restore.
    selectedClass := nil.
    self
        changed: #selectors: ;
        changed: #instanceVars: ;
        changed: #text:! !



!ClassHierarchyBrowser methods !

 
isWBClassBrowser
    "Added by OSI"
    #addedByOSI.
    ^true!  !



!ClassHierarchyBrowser methods !

 
fileOut
        "Private - Write the source for the selected class
         in chunk file format to a file named with the class
         name reduced to 8 characters, extension 'cls'."
    | file |
    selectedClass isNil
        ifTrue: [^self].
    file := (FileDialog new
        saveTitle: 'File out ', selectedClass name, ' class'
        fileName: (
            File
                fileName: selectedClass name
                extension: 'cls')) file.
    file isNil ifTrue: [^self].
    (ClassReader forClass: selectedClass) fileOut: file!   !



!ClassHierarchyBrowser methods !

 
gsMenu

    ^(Menu
        labels: 'Implementors\Senders' withCrs
        lines: #(4 6 10)
        selectors: #(gsImplementors gsSenders))
            title: '&GSExtras';
            owner: self;
            yourself!   !



!ClassHierarchyBrowser methods !

 
openWindow

    super openWindow.
    self menuWindow addMenu: self gsMenu.! !



!ClassHierarchyBrowser methods !

 
selectorMenu: selectorPane
        "Private - Set the selector pane menu."
    selectorPane setMenu: ((Menu
        labels: '&New Method\&Senders\&Implementors\Local Senders\Local Implementors\&Messages\&File Out...\&Remove' withCrs
        lines: #(1 6)
        selectors: #( newMethod senders implementors localSenders localImplementors messages fileOutMethod removeSelector))
            title: '&Methods';
            owner: self;
            yourself)!   !



!ClassHierarchyBrowser methods !

 
instanceVar: instVarPane
        "Private - An instance variable was selected."
    selectedInstVar := instVarPane selectedItem.
    methodSelectedLast := false.
    self disableMethodsMenu.
    self changed: #selectors:.
    self changed: #text:!   !



!ClassHierarchyBrowser methods !

 
instanceVars: instVarPane
        "Private - Set the list of instance variables."
    | aClass |
    selectedClass isNil
        ifTrue: [^instVarPane contents: Array new].
    instanceSelectedLast
        ifTrue: [aClass := selectedClass]
        ifFalse: [aClass := selectedClass class].
     self checkMenuForInstanceVariable.
     instVarPane contents: aClass allInstAndClassVarNamesGrouped.!   !



!ClassHierarchyBrowser methods !

 
openOn: aCollection
        "Create a class hierarchy browser window giving access
         to the classes in aCollection and their subclasses."
    | ratio groupPane |
    hiddenClasses := Set new.
    (aCollection includes: Object)
        ifTrue: [
            aCollection do: [ :class |
                class subclasses do: [:each |
                    each subclasses isEmpty
                        ifFalse: [
                            hiddenClasses add: each]]]]
        ifFalse: [
            aCollection do: [ :class |
                class subclasses isEmpty
                    ifFalse: [
                        hiddenClasses add: class]]].
    ratio := 2 / 5.
    self update: aCollection.
     instanceSelectedLast := true.
    methodSelectedLast := false.
    assigned := used := true.
    self
        owner: self;
        label: self label;
        icon: (Icon fromModule: Icon defaultDLLFileName id:'ClassHierarchyBrowser').
    self addSubpane:
        (ListBox new
            owner: self;
            when: #getContents perform: #hierarchy: ;
            when: #select perform: #hierarchySelected: ;
            when: #doubleClickSelect perform: #hideShow: ;
            when: #getMenu perform: #menu: ;
            when: #charInput perform: #hierarchyCharInput: ;
            framingRatio:
                (Rectangle leftTopUnit extentFromLeftTop: 3/8 @ ratio)).
    self addSubpane:
        (ListBox new
            owner: self;
            when: #getContents perform: #instanceVars: ;
            when: #select perform: #instanceVar: ;
            when: #getMenu perform: #instVarsMenu: ;
            framingBlock: [:box|
                box leftTop + ((box width * 3/8) truncated @ (2 *
                    (ButtonFont height + 4) ))
                  rightBottom: (box width * 5//8) @ ((box height * ratio) truncated)]).
    self addSubpane:
        (ListBox new
            owner: self;
            when: #getContents perform: #selectors: ;
            when: #select perform: #selector: ;
            when: #getMenu perform: #selectorMenu: ;
            framingRatio:
                (Rectangle leftTopUnit + (5/8 @ 0)
                    extentFromLeftTop: 3/8 @ ratio)).
    self addSubpane: (groupPane := GroupPane new
        framingBlock: [:box| box leftTop + ((box width * 3//8) @ 0)
            rightBottom: ((box width * 5//8)@(box leftTop y + (2 *
                    (ButtonFont height + 4) )))]).
    groupPane addSubpane:
        (RadioButton new
            owner: self;
            contents: 'instance';
            when: #clicked perform: #instanceButton:;
            selection: true;
            framingRatio: (1/15 @ 0 extentFromLeftTop: 14/15 @ (1/2))).
    groupPane addSubpane:
        (RadioButton new
            owner: self;
            contents: 'class';
            when: #clicked perform: #classButton:;
            framingRatio: (1/15 @ (1/2) extentFromLeftTop: 14/15 @ (1/2))).
    self addSubpane:
        (TextPane new
            owner: self;
            when: #getContents perform: #text: ;
            when: #save perform: #accept: ;
            framingRatio: (Rectangle leftBottomUnit
              extentFromLeftBottom: 1 @ (1 - ratio))).
    self openWindow.
    self disableClassesMenu.
    self disableMethodsMenu.
    self checkInstVarMenu! !



!ClassHierarchyBrowser methods !

 
localImplementors
        "Private - Pop-up a window with the
         implementors of the selected method."
    selectedMethod isNil
        ifFalse: [Smalltalk implementorsOf: selectedMethod in: selectedClass]!    !



!ClassHierarchyBrowser methods !

 
instVarsMenu: instVarPane
        "Private - Set the menu for the instance variables pane."
    instVarPane setMenu: ((Menu
        labels: '&Assigned\&Used\&Both' withCrs
        lines: #()
        selectors: #(assigned used bothInstVars))
            title: '&Variables';
            owner: self;
            yourself)!   !



!ClassHierarchyBrowser methods !

 
used
        "Private - The Used menu item was selected."
    used := true.
    assigned := false.
    self checkInstVarMenu.
    self changed: #selectors:!   !



!ClassHierarchyBrowser methods !

 
fixHideShowItem: hidden
        "Private - Change the Hide/Show menu item."
    | menu |
    menu := (self menuTitled: '&Classes').
    hidden
        ifTrue: [
            menu changeItem: #hideShow label: '&Show Subclasses'.
            menu enableItem: #hideShow]
        ifFalse: [
            selectedClass subclasses isEmpty
                ifTrue: [
                    menu changeItem: #hideShow label: 'Hide/Show'.
                    menu disableItem: #hideShow]
                ifFalse: [
                    menu changeItem: #hideShow label: '&Hide Subclasses'.
                    menu enableItem: #hideShow]]!  !



!ClassHierarchyBrowser methods !

 
statusPaneHelp:aKey
        "Private - Answer the default dictionary used by
        the status bar for help support."

    ^HelpClassHierarchyBrowser at:aKey ifAbsent:[^super statusPaneHelp:aKey]!   !



!ClassHierarchyBrowser methods !

 
template
        "Private - Answer the
         template for methods."
    ^'messagePattern
        "comment"
    | temporaries |
    statements'!    !



!ClassHierarchyBrowser methods !

 
acceptClass: aString from: aPane
		"Private - Accept aString as an updated
		 class specification and compile it.  Notify
		 aPane if the compiler detects errors."
	| result |
	result := Compiler
		evaluate: aString
		in: nil class
		to: nil
		notifying: aPane
		ifFail: [^true].
	Smalltalk logEvaluate: aString.
	result isClass ifTrue: [selectedClass := result].
	self
		changed: #instanceVars:;
		changed: #text: .
	^result isClass not!  !



!ClassHierarchyBrowser methods !

 
hierarchySearchFor: aChar in: aPane
        "Private - Search aChar from the selected item in aPane."
    (self hierarchySearchFor: aChar
        from: aPane selectedIndex
        in: aPane) isNil ifTrue: [
            (self hierarchySearchFor: aChar from: 0 in: aPane)]!    !



!ClassHierarchyBrowser methods !

 
messages
        "Private"
    selectedMethod notNil ifTrue: [
        CursorManager execute change.
        SelectorBrowser new openOn:
            ((instanceSelectedLast
                ifTrue: [selectedClass]
                ifFalse: [selectedClass class])
                    compiledMethodAt: selectedMethod).
        CursorManager normal change]!   !



!ClassHierarchyBrowser methods !

 
gsSenders


        GsSendersView open.! !



!ClassHierarchyBrowser methods !

 
selectedMethod

    "Added by OSI"
    #addedByOSI.
    ^selectedMethod!    !



!ClassHierarchyBrowser methods !

 
newMethod
		"Private - Display the text for a new
		 method template in the text pane."
	selectedClass isNil
		ifTrue: [self error: 'no class selected'].
	self textModified
		ifFalse: [
			self
				changed: #selectors:;
				selector: nil;
				disableMethodsMenu.
			(self paneAt: #text:) selectAll]!  !



!ClassHierarchyBrowser methods !

 
disableClassesMenu
        "Private - Disable the classes menu."
    (self menuTitled: '&Classes')
        disableItem: #removeSubClass;
        disableItem: #fileOut;
        disableItem: #fileOutWithSubclasses;
        disableItem: #hideShow;
        disableItem: #browse;
        disableItem: #addSubClass!   !



!ClassHierarchyBrowser methods !

 
hideShow
        "Private - Change the hide/show
         status of the selected class."
    selectedClass isNil
        ifTrue: [^nil].
    CursorManager execute change.
    (hiddenClasses includes: selectedClass)
        ifTrue: [
            hiddenClasses remove: selectedClass.
            self fixHideShowItem: false]
        ifFalse: [
            selectedClass subclasses isEmpty
                ifFalse: [
                    hiddenClasses add: selectedClass.
                    self fixHideShowItem: true]].
    methodSelectedLast := false.
    selectedMethod := nil.
    self
        update: originalClasses;
        changed: #hierarchy:
            with: #restoreSelected.
    CursorManager normal change.! !



!ClassHierarchyBrowser methods !

 
selectors: selectorPane
        "Private - Set the sorted list of method
         selectors for the selected class and
         dictionary type (class or instance)."
    | methods|
    selectedClass isNil
        ifTrue: [^selectorPane contents: Array new].
    instanceSelectedLast
        ifTrue: [
            selectedInstVar isNil
                ifTrue: [^selectorPane contents: selectedClass selectors asSortedCollection].

                (methods := selectedClass allMethodsUsingClassVar: selectedInstVar) isEmpty
                    ifFalse:[ "selected variable was a class variable"
                        self checkMenuForClassVariable.
                        ^selectorPane contents: (methods collect: [:m | m selector]) asSortedCollection]
                    ifTrue:["selected variable was a instance variable"
                        self checkMenuForInstanceVariable.
                        methods := assigned
                        ifTrue: [
                            used
                                ifTrue: [selectedClass allMethodsReferencingInstVar: selectedInstVar]
                                ifFalse: [selectedClass allMethodsAssigningInstVar: selectedInstVar]]
                        ifFalse: [
                            used
                                ifTrue: [selectedClass allMethodsUsingInstVar: selectedInstVar]
                                ifFalse: [^selectorPane contents: selectedClass selectors asSortedCollection]].
                         ^selectorPane contents: (methods collect: [:m | m selector]) asSortedCollection]]
        ifFalse: [
            selectedInstVar isNil
                ifTrue: [^selectorPane contents: selectedClass class selectors asSortedCollection]
                ifFalse: [
                    methods := selectedClass class allMethodsUsingClassVar: selectedInstVar.
                    ^selectorPane contents: (methods collect: [:m | m selector]) asSortedCollection]].! !



!ClassHierarchyBrowser methods !

 
removeSelector
        "Private - Remove the selected method."
    | aString |
    methodSelectedLast
        ifFalse: [^nil].
    selectedMethod isNil
        ifTrue: [^nil].
    instanceSelectedLast
        ifTrue: [
            selectedClass removeSelector:
                selectedMethod.
            aString := selectedClass name]
        ifFalse: [
            selectedClass class removeSelector:
                selectedMethod.
            aString := selectedClass class name].
    Smalltalk logEvaluate:
        aString, ' removeSelector: #', selectedMethod.
    methodSelectedLast := false.
    selectedMethod := nil.
    self
        changed: #selectors: with: #restore;
        changed: #text:! !



!ClassHierarchyBrowser methods !

 
instance
        "Private - Change the state of the browser
         so that instance messages are selected."
    instanceSelectedLast := true.
    methodSelectedLast := false.
    self
        "changed: #classes;"
        changed: #selectors: ;
        changed: #text:!  !



!ClassHierarchyBrowser methods !

 
menu: hierarchyPane
        "Private - Set the hierarchy pane menu."
    hierarchyPane setMenu: ((Menu
        labels: 'Add Subclass...\Delete Class\Rename Class\Move Class\File &Out...\File Ou&t All...\&Update\&Hide/Show\&Browse\&Find Class...\Generate Methods\Subpart Features' withCrs
        lines: #(4 6 10)
        selectors: #(addSubClass removeSubClass gsRenameClass gsMoveClass fileOut fileOutWithSubclasses update hideShow browse findClass gsGenerateMethods gsGeneratePartNames ))
            title: '&Classes';
            owner: self;
            yourself)!   !



!ClassHierarchyBrowser methods !

 
implementors
        "Private - Pop-up a window with the
         implementors of the selected method."
    selectedMethod isNil
        ifFalse: [Smalltalk implementorsOf: selectedMethod]!   !



!ClassHierarchyBrowser methods !

 
enableMethodsMenu
        "Private - Enable the methods menu."
    (self menuTitled: '&Methods')
        enableItem: #removeSelector;
        enableItem: #newMethod;
        enableItem: #senders;
        enableItem: #implementors;
        enableItem: #messages;
        enableItem: #localSenders;
        enableItem: #localImplementors;
        enableItem: #fileOutMethod.! !



!ClassHierarchyBrowser methods !

 
instanceButton: aButton
        "Private - Change the state of the browser
         so that instance messages are selected."
    self textModified ifTrue: [
        self changed: 'instance' with: instanceSelectedLast.
        self changed: 'class' with: instanceSelectedLast not.
        ^self].
    instanceSelectedLast := true.
    methodSelectedLast := false.
    selectedInstVar := nil.
    self disableMethodsMenu.
    self
        changed: #instanceVars: ;
        changed: #selectors: ;
        changed: #text:!    !



!ClassHierarchyBrowser methods !

 
gsRenameClass

    GsClassHierarchyRouter gsOpenRenameClassViewFor: self selectedClass parentView: self.! !



!ClassHierarchyBrowser methods !

 
openPartNamesWindow

    GsPartNameListView newOn: self selectedClass.!   !



!ClassHierarchyBrowser methods !

 
localSenders
        "Private - Pop-up a window with the
         senders of the selected method."
    selectedMethod isNil
        ifFalse: [Smalltalk sendersOf: selectedMethod in: selectedClass]!   !



!ClassHierarchyBrowser methods !

 
checkInstVarMenu
        "Private - Check the appropriate item in the instance
         variables menu."
    | menu |
    menu := (self menuTitled: '&Variables').
    menu
        uncheckItem: #assigned;
        uncheckItem: #used;
        uncheckItem: #bothInstVars.
    assigned & used ifTrue: [^menu checkItem: #bothInstVars].
    assigned ifTrue: [^menu checkItem: #assigned].
    used ifTrue: [^menu checkItem: #used]!  !



!ClassHierarchyBrowser methods !

 
text: textPane
		"Private - Set the source text for
		 the selected method or class definition
		 for the selected class."
	| answer aClass |
	selectedClass isNil
		ifTrue: [^textPane contents: String new].
	aClass := instanceSelectedLast
		ifTrue: [selectedClass]
		ifFalse: [selectedClass class].
	methodSelectedLast
		ifTrue: [
			aClass := instanceSelectedLast
				ifTrue: [selectedClass]
				ifFalse: [selectedClass class].
			selectedMethod isNil
				ifTrue: [^textPane contents: self template]
				ifFalse: [^textPane contents: (aClass sourceCodeAt: selectedMethod)]].
	answer := WriteStream on: (String new: 100).
	aClass fileOutOn: answer.
	textPane contents: answer contents!   !



!ClassHierarchyBrowser methods !

 
bothInstVars
        "Private - The user chose the Both menu item."
    assigned := true.
    used := true.
    self checkInstVarMenu.
    self changed: #selectors:!  !



!ClassHierarchyBrowser methods !

 
fileOutMethod
        "Private - Write the source for the selected method
         in chunk file format to a file named with the method
         name reduced to 8 characters, extension 'mth'."
    | file |
    selectedClass isNil ifTrue: [^self].
    selectedMethod isNil ifTrue: [^self].
    file := (FileDialog new
        saveTitle: 'File out ', selectedMethod, ' method'
        fileName: (
            File
                fileName: (selectedMethod reject: [:c| c = $:])
                extension: 'mth')) file.
    file isNil ifTrue: [^self].
    file := File newFile: file.
    (ClassReader forClass:
        (instanceSelectedLast
                ifTrue: [selectedClass]
                ifFalse: [selectedClass class]))
        fileOutMethod: selectedMethod on: file.
    file close.! !



!ClassHierarchyBrowser methods !

 
hierarchySearchFor: aChar from: index in: aPane
        "Private - Search for aChar from index (not including)."
    | class |
    (index max: 1) to: browsedClasses size do: [:i |
        class := (browsedClasses at: i) trimBlanks.
        ((class at: 1) = aChar and: [i ~= index])
            ifTrue: [
                aPane selection: i.
                self hierarchySelected: (self paneAt: #hierarchy:).
                ^self ]
            ifFalse: [
                (class last = $.)
                    ifTrue: [
                        (self hierarchySearch: aChar
                            class: (Smalltalk at: (class copyFrom: 1
                                to: class size - 3) asSymbol)
                            index: i
                            in: aPane)
                                notNil ifTrue: [
                                    self hierarchySelected: (self paneAt: #hierarchy:).
                                    ^self]]]].
    ^nil!   !



!ClassHierarchyBrowser methods !

 
enableClassesMenu
        "Private - Enable the classes menu."
    (self menuTitled: '&Classes')
        enableItem: #removeSubClass;
        enableItem: #fileOut;
        enableItem: #fileOutWithSubclasses;
        enableItem: #hideShow;
        enableItem: #browse;
        enableItem: #addSubClass!   !



!ClassHierarchyBrowser methods !

 
addSubClass 
        "Private - Add a subclass to the selected 
         class.  If a class is selected, prompt the 
         user for a new class name and add it as a 
         subclass to the selected class." 
    | newSubclassDialog newName subclassType | 
    selectedClass isNil ifTrue: [selectedClass := Object]. 
    newSubclassDialog := NewSubclassDialog open: selectedClass. 
    newName := newSubclassDialog subclassName. 
    (newName isNil or: [newName isEmpty]) 
        ifTrue: [^nil]. 
    (newName at: 1) isUpperCase 
        ifFalse: [ 
            newName at: 1 
            put: (newName at: 1) asUpperCase]. 
    newName := newName asSymbol. 
    (Smalltalk includesKey: newName) 
        ifTrue: [^self error: newName, ' already exists']. 
    subclassType := newSubclassDialog isFixed 
        ifTrue: [#pointer] 
        ifFalse: [newSubclassDialog isPointer 
            ifTrue: [#indexed] 
            ifFalse: [#byte]]. 
    (subclassType == #pointer and: [selectedClass isVariable]) 
        ifTrue: [ 
            (MessageBox confirm: 'Indexed pointer subclass assumed') 
                ifFalse: [^self]]. 
    subclassType == #pointer 
        ifTrue: [ 
            ((selectedClass subclass: newName 
                instanceVariableNames: '' 
                classVariableNames: '' 
                poolDictionaries: '') 
                    isKindOf: Class) 
                        ifFalse: [^self]]. 
    subclassType == #indexed 
        ifTrue: [ 
            ((selectedClass variableSubclass: newName 
                instanceVariableNames: '' 
                classVariableNames: '' 
                poolDictionaries: '') 
                    isKindOf: Class) 
                        ifFalse: [^self]]. 
    subclassType == #byte 
        ifTrue: [ 
            ((selectedClass variableByteSubclass: newName 
                classVariableNames: '' 
                poolDictionaries: '') 
                    isKindOf: Class) 
                        ifFalse: [^self]]. 
    subclassType isNil ifTrue: [^self]. 
    selectedClass := Smalltalk at: newName asSymbol. 
    CursorManager execute change. 
    selectedMethod := nil. 
    methodSelectedLast := false. 
    self update: originalClasses. 
    self 
        changed: #hierarchy: 
        with: #restoreSelected: 
        with: ((String new: 
            (Smalltalk at: newName asSymbol) 
                allSuperclasses size * 2) 
                    atAllPut: $ ), newName. 
    self 
        changed: #selectors: ; 
        changed: #instanceVars: ; 
        changed: #text:!    !



!ClassHierarchyBrowser methods !

 
openSelecting: selectingClass

    "Added by OSI"

    | aCollection blanks supers ratio groupPane |
    #addedByOSI.
    aCollection := Array with: Object.

    hiddenClasses := Set new.
    aCollection do: [ :class |
        class subclasses do: [:each |
            each subclasses isEmpty ifFalse: [
                hiddenClasses add: each
            ]
        ]
    ].

    ratio := 2 / 5.
    self update: aCollection.
     instanceSelectedLast := true.
    methodSelectedLast := false.
    assigned := used := true.
    self
        owner: self;
        label: self label.
    self addSubpane:
        (ListBox new
            owner: self;
            when: #getContents perform: #hierarchy: ;
            when: #select perform: #hierarchySelected: ;
            when: #doubleClickSelect perform: #hideShow: ;
            when: #getMenu perform: #menu: ;
            when: #charInput perform: #hierarchyCharInput: ;
            framingRatio:
                (Rectangle leftTopUnit extentFromLeftTop: 3/8 @ ratio)).
    self addSubpane:
        (ListBox new
            owner: self;
            when: #getContents perform: #instanceVars: ;
            when: #select perform: #instanceVar: ;
            when: #getMenu perform: #instVarsMenu: ;
            framingBlock: [:box|
                box leftTop + ((box width * 3/8) truncated @ (2 *
                    (ButtonFont height + 4) ))
                  rightBottom: (box width * 5//8) @ ((box height * ratio) truncated)]).
    self addSubpane:
        (ListBox new
            owner: self;
            when: #getContents perform: #selectors: ;
            when: #select perform: #selector: ;
            when: #getMenu perform: #selectorMenu: ;
            framingRatio:
                (Rectangle leftTopUnit + (5/8 @ 0)
                    extentFromLeftTop: 3/8 @ ratio)).
    self addSubpane: (groupPane := GroupPane new
        framingBlock: [:box| box leftTop + ((box width * 3//8) @ 0)
            rightBottom: ((box width * 5//8)@(box leftTop y + (2 *
                    (ButtonFont height + 4) )))]).
    groupPane addSubpane:
        (RadioButton new
            owner: self;
            contents: 'instance';
            when: #clicked perform: #instanceButton:;
            selection: true;
            framingRatio: (1/15 @ 0 extentFromLeftTop: 14/15 @ (1/2))).
    groupPane addSubpane:
        (RadioButton new
            owner: self;
            contents: 'class';
            when: #clicked perform: #classButton:;
            framingRatio: (1/15 @ (1/2) extentFromLeftTop: 14/15 @ (1/2))).
    self addSubpane:
        (TextPane new
            owner: self;
            when: #getContents perform: #text: ;
            when: #save perform: #accept: ;
            framingRatio: (Rectangle leftBottomUnit
              extentFromLeftBottom: 1 @ (1 - ratio))).
    supers := (Array with: class), selectingClass allSuperclasses.
    blanks := 0.
    1 to: supers size do: [ :i |
        (originalClasses includes: (supers at: i))
           ifTrue: [ blanks := i ]].
    supers do: [ :cl |
        hiddenClasses remove: cl ifAbsent: []].

    self openWindow.

    self update: originalClasses.
    methodSelectedLast := false.
    selectedMethod := nil.
    selectedInstVar := nil.
    selectedClass := selectingClass.
    self changed: #hierarchy:
        with: #restoreSelected:
        with: (((String new: ((blanks - 1 max: 0) * 2)) atAllPut: $ ),
            selectingClass name).
    self
        changed: #instanceVars: ;
        changed: #selectors: ;
        changed: #text:.
    CursorManager normal change.!  !



!ClassHierarchyBrowser methods !

 
gsMoveClass

    GsClassHierarchyRouter gsOpenMoveViewFor: self selectedClass parentView: self.!  !



!GsImplementorsView class methods !

  
wbCreated

    ^true! !



!String class methods !

  
fromModule: aModuleName id: anInteger
        "Load the string from the module
         aModuleName with anInteger id."
    | modHandle numBytes stringBuffer |
    modHandle := DynamicLinkLibrary open: aModuleName.
    modHandle isDynamicLinkLibrary ifFalse: [
        ^self error: 'cannot open module'].
    stringBuffer := String new: 256.
    numBytes := UserLibrary loadString: modHandle
        id: anInteger
        buffer: stringBuffer maxChars: 256.
    modHandle close.
    numBytes = 0 ifTrue: [^self error: 'load string error'].
    ^(stringBuffer copyFrom: 1 to: numBytes) asNormalizedString!   !



!String class methods !

  
fromAddress: aWinAddress length: anInteger
        "Answer a string of size anInteger whose bytes
         are copied from system memory at aWinAddress."
    | t |
    t := self new: anInteger.
    t replaceFrom: 1
          to: anInteger
          withAddress: aWinAddress
          startingAt: 1.
   ^t asNormalizedString!   !



!String class methods !

  
fromAddress: aWinAddress
        "Answer a string whose bytes are copied from
         system memory at aWinAddress."
    | s i |
    s := self new: 1.
    i := 1.
    [s replaceFrom: 1
          to: 1
          withAddress: aWinAddress
          startingAt: i.
    (s at: 1) asciiValue = 0] whileFalse: [i := i + 1].
    ^self fromAddress: aWinAddress length: i - 1.! !



!GsAbstractModel methods !

   
isPersistent

     ^isPersistent! !



!GsAbstractModel methods !

   
isPersistent: anObject

     isPersistent := anObject.
     self signalEvent: #isPersistent
          with: anObject.
     ^isPersistent!  !



!GsMethodGeneratorSelectionView methods !


objectClass


    ^objectClass!  !



!GsMethodGeneratorSelectionView methods !


openedWidget: aPane

    "Callback for the #opened event in the TopPane 'mainView'.
     (Generated by WindowBuilder)"

    self label: 'Generate Methods For',self objectClass asString.! !



!GsMethodGeneratorSelectionView methods !


possibleVars: anObject

     possibleVars := anObject.
     self signalEvent: #possibleVars
          with: anObject.
     ^possibleVars!  !



!GsMethodGeneratorSelectionView methods !


getContentsSelectedInstVars: aPane

    "Callback for the #getContents event in the ListBox named 'selectedInstVars'.
     (Generated by WindowBuilder)"

      (self paneNamed: 'selectedInstVars') contents: OrderedCollection new.! !



!GsMethodGeneratorSelectionView methods !


closeButtonPressed: aPane

    "Callback for the #clicked event in the Button named 'closeButton'.
     (Generated by WindowBuilder)"

    self closeWindow.!  !



!GsMethodGeneratorSelectionView methods !


generateSelected: aPane

    "Callback for the #clicked event in the Button named 'okPushButton'.
     (Generated by WindowBuilder)"

    GsMethodGenerator
        generateMethods: self selectedVars asOrderedCollection
        forClass: self objectClass.

    self closeWindow.! !



!GsMethodGeneratorSelectionView methods !


possibleVars

     ^possibleVars! !



!GsMethodGeneratorSelectionView methods !


selectedVars: anObject

     selectedVars := anObject.
     self signalEvent: #selectedVars
          with: anObject.
     ^selectedVars!  !



!GsMethodGeneratorSelectionView methods !


getContentsPossibleInstVars: aPane

    "Callback for the #getContents event in the ListBox named 'possibleInstVars'.
     (Generated by WindowBuilder)"

   (self paneNamed: 'possibleInstVars') contents: self possibleVars! !



!GsMethodGeneratorSelectionView methods !


generateAll: aPane

    "Callback for the #clicked event in the Button named 'generateAllPushButton'.
     (Generated by WindowBuilder)"

    GsMethodGenerator
        generateMethods: self possibleVars asOrderedCollection
        forClass: self objectClass.

    self closeWindow.! !



!GsMethodGeneratorSelectionView methods !


moveToSelectedPane: aPane

    "Callback for the #clicked event in the Button named 'arrowButton'.
     (Generated by WindowBuilder)"

    |newOC oldOC|

    (self paneNamed: 'possibleInstVars') selectedItem isNil
        ifTrue:[^false].

    newOC := (self paneNamed: 'selectedInstVars') contents .
    newOC add: (self paneNamed: 'possibleInstVars') selectedItem.
    (self paneNamed: 'selectedInstVars') contents:  newOC.

    oldOC := (self paneNamed: 'possibleInstVars') contents.
    self selectedVars add: (self paneNamed: 'possibleInstVars') selectedItem.
    oldOC remove: (self paneNamed: 'possibleInstVars') selectedItem.
    (self paneNamed: 'possibleInstVars') contents: oldOC.!   !



!GsMethodGeneratorSelectionView methods !


moveToAvailablePane: aPane

    "Callback for the #clicked event in the Button named 'rightArrowButton'.
     (Generated by WindowBuilder)"


    |newOC oldOC|

    (self paneNamed: 'selectedInstVars') selectedItem isNil
        ifTrue:[^false].

    newOC := (self paneNamed: 'possibleInstVars') contents .
    newOC add: (self paneNamed: 'selectedInstVars') selectedItem.
    (self paneNamed: 'possibleInstVars') contents:  newOC.

    oldOC := (self paneNamed: 'selectedInstVars') contents.
    self selectedVars add: (self paneNamed: 'selectedInstVars') selectedItem.
    oldOC remove: (self paneNamed: 'selectedInstVars') selectedItem.
    (self paneNamed: 'selectedInstVars') contents: oldOC.!   !



!GsMethodGeneratorSelectionView methods !


createViews

     "WARNING!!  This method was automatically generated by
      WindowBuilder.  Code you add here which does not conform
      to the WindowBuilder API will probably be lost the next time
      you save your layout definition."

     | v |

    self addView: (
        v := self topPaneClass new
            owner: self;
            labelWithoutPrefix:  'Generate methods';
            noSmalltalkMenuBar;
            viewName: 'mainView';
            framingBlock: ( FramingParameters new iDUE: 1189 @ 856; xC; yC; cRDU: (9 @ 848 rightBottom: 1179 @ 46));
            pStyle: #(sysmenu maximize titlebar sizable minimize);
            when: #opened perform: #openedWidget:;
            addSubpane: (
                ListBox new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 466 @ 582; lDU: 37 r: #left; rP: 55/128; tDU: 50 r: #top; bDU: 170 r: #bottom);
                    paneName: 'possibleInstVars';
                    startGroup;
                    tabStop;
                    when: #getContents perform: #getContentsPossibleInstVars:;
                    yourself
            );
            addSubpane: (
                Button new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 82 @ 64; xC; tDU: 152 r: #top; bDU: 216 r: #top);
                    paneName: 'leftArrowButton';
                    startGroup;
                    tabStop;
                    when: #clicked perform: #moveToSelectedPane:;
                    contents: '>>';
                    yourself
            );
            addSubpane: (
                ListBox new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 457 @ 574; lP: 37/64; rDU: 37 r: #right; tDU: 50 r: #top; bDU: 178 r: #bottom);
                    paneName: 'selectedInstVars';
                    startGroup;
                    tabStop;
                    when: #getContents perform: #getContentsSelectedInstVars:;
                    yourself
            );
            addSubpane: (
                Button new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 320 @ 64; lDU: 530 r: #right; rDU: 210 r: #right; tDU: 90 r: #bottom);
                    paneName: 'okPushButton';
                    idOK;
                    startGroup;
                    when: #clicked perform: #generateSelected:;
                    contents: 'Generate Selected';
                    yourself
            );
            addSubpane: (
                Button new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 229 @ 64; lDU: 795 r: #right; rDU: 567 r: #right; tDU: 90 r: #bottom);
                    paneName: 'generateAllPushButton';
                    startGroup;
                    when: #clicked perform: #generateAll:;
                    contents: 'Generate All';
                    yourself
            );
            addSubpane: (
                Button new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 146 @ 64; lDU: 183 r: #right; rDU: 37 r: #right; tDU: 90 r: #bottom);
                    paneName: 'closeButton';
                    idCancel;
                    startGroup;
                    when: #clicked perform: #closeButtonPressed:;
                    contents: 'Close';
                    yourself
            );
            addSubpane: (
                Button new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 82 @ 64; xC; tDU: 240 r: #top; bDU: 304 r: #top);
                    paneName: 'rightArrowButton';
                    startGroup;
                    when: #clicked perform: #moveToAvailablePane:;
                    contents: '<<';
                    yourself
            );
        yourself
    ).!  !



!GsMethodGeneratorSelectionView methods !


objectClass: aClass


    objectClass  := aClass!    !



!GsMethodGeneratorSelectionView methods !


selectedVars

    selectedVars isNil
        ifTrue:[
            selectedVars := OrderedCollection new].

     ^selectedVars!    !



!GsEventHandlerManager class methods !

   
processEvent: anEvent for: anObject  with: args

    | associations toBeRemoved |
    associations := (self handlerTable at: anEvent ifAbsent:[nil]).
    toBeRemoved := OrderedCollection new.
    associations isNil
        ifFalse:[
            associations do:[:e |
                e key == anObject
                    ifTrue:[
                        self fixArgsFor: e value arguments with: args.
                        e value perform]
                    ifFalse:[
                        e key == nil
                            ifTrue:
                                [toBeRemoved add: e]]]]
        ifTrue:[^nil].

    associations removeAll: toBeRemoved.
    self clearOldObjectKeysAndDeadObjects.!    !



!GsEventHandlerManager class methods !

   
fixArgsFor: argsArray with: eventArgsanArray

    argsArray size =  eventArgsanArray size
        ifTrue:[
            argsArray copyReplaceFrom: 1 to: argsArray size with: eventArgsanArray]
        ifFalse:[
            self error: 'There are too may arguments!!']!    !



!GsEventHandlerManager class methods !

   
clearOldObjectKeysAndDeadObjects

    [self sweepOut.

    self handlerTable keys do:[:e |
        (self handlerTable at: e) isEmpty
            ifTrue: [self handlerTable removeKey: e]]] forkAt: 3.!   !



!GsEventHandlerManager class methods !

   
clearEventsNotificationsFor: anObject

    | throwAwayAssociations currentAssociations |

    throwAwayAssociations := Set new.
    currentAssociations := Set new.

    self handlerTable keys
        do:[:ekey |
            currentAssociations := (self handlerTable at: ekey).
            throwAwayAssociations addAll: (currentAssociations select:[:e | e key = anObject]).
            throwAwayAssociations isEmpty
                ifFalse:[
                    currentAssociations removeAll: throwAwayAssociations].
            throwAwayAssociations := Set new.
            currentAssociations := Set new]!   !



!GsEventHandlerManager class methods !

   
sweepOut

    self handlerTable keys
        do:[:ekey |
            (self handlerTable at: ekey)
                do:[:e |
                (e key allReferences size = (self referencesInHandlerTableTo: e key))
                    ifTrue:[self clearEventsNotificationsFor: e key]]]! !



!GsEventHandlerManager class methods !

   
referencesInHandlerTableTo: anObject

    | count |

    count := 0.
    self handlerTable keys do:[:e |
        (self handlerTable at: e) do:[:h |
                h key = anObject ifTrue:[count := count +1]]].

    ^count!    !



!GsEventHandlerManager class methods !

   
atEvent: anEvent putMessage: aMessage for: anObject

    self handlerTable
        at: anEvent
        ifAbsent:[
            self handlerTable
                at: anEvent
                put: OrderedCollection new].

    (self handlerTable at: anEvent )add: (Association key:anObject value: aMessage).!    !



!GsEventHandlerManager class methods !

   
handlerTable

    HandlerTable isNil
        ifTrue:[
            HandlerTable := Dictionary new].

    ^HandlerTable!    !



!GsImplementorsView methods !


createViews

     "WARNING!!  This method was automatically generated by
      WindowBuilder.  Code you add here which does not conform
      to the WindowBuilder API will probably be lost the next time
      you save your layout definition."

     | v |

    self addView: (
        v := self topPaneClass new
            owner: self;
            labelWithoutPrefix:  'Implementors';
            noSmalltalkMenuBar;
            viewName: 'mainView';
            framingBlock: ( FramingParameters new iDUE: 686 @ 240; xC; yC; cRDU: (2 @ 238 rightBottom: 683 @ 40));
            pStyle: #(sysmenu titlebar);
            addSubpane: (
                GsEntryFieldCompositePane new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 585 @ 138; xC; yC);
                    addSubpanes;
                    startGroup;
                    when: #ok perform: #okClicked:;
                    when: #cancel perform: #cancelClicked:;
                    yourself
            );
        yourself
    ).!   !



!GsImplementorsView methods !


cancelClicked: aPane

    "Callback for the #cancel event in an unnamed GsEntryFieldCompositePane.
     (Generated by WindowBuilder)"


    self closeWindow! !



!GsImplementorsView methods !


okClicked: aPane

    "Callback for the #ok event in an unnamed GsEntryFieldCompositePane.
     (Generated by WindowBuilder)"

     (Smalltalk implementorsOf: ((self paneNamed: 'entryField') contents asSymbol)).
    self closeWindow.!    !



!GsSendersView methods !

 
okClicked: aPane

    "Callback for the #ok event in an unnamed GsEntryFieldCompositePane.
     (Generated by WindowBuilder)"

    Smalltalk sendersOf: ((self paneNamed: 'entryField') contents asSymbol).
    self closeWindow.!    !



!GsSendersView methods !

 
createViews

     "WARNING!!  This method was automatically generated by
      WindowBuilder.  Code you add here which does not conform
      to the WindowBuilder API will probably be lost the next time
      you save your layout definition."

     | v |

    self addView: (
        v := self topPaneClass new
            owner: self;
            labelWithoutPrefix:  'Senders';
            noSmalltalkMenuBar;
            viewName: 'mainView';
            framingBlock: ( FramingParameters new iDUE: 686 @ 240; xC; yC; cRDU: (2 @ 238 rightBottom: 683 @ 40));
            pStyle: #(sysmenu titlebar);
            addSubpane: (
                GsEntryFieldCompositePane new
                    owner: self;
                    framingBlock: ( FramingParameters new iDUE: 585 @ 138; xC; yC);
                    addSubpanes;
                    startGroup;
                    when: #cancel perform: #cancelClicked:;
                    when: #ok perform: #okClicked:;
                    yourself
            );
        yourself
    ).!    !



!GsSendersView methods !

 
cancelClicked: aPane

    "Callback for the #cancel event in an unnamed GsEntryFieldCompositePane.
     (Generated by WindowBuilder)"

    self closeWindow.!  !



!GsSendersView class methods !

   
wbCreated

    ^true! !



!GsMethodGenerator class methods !

   
setterTemplate

^'aSetter: anObject
    "Generated setter for aSetter"

    aSetter := anObject.

    self signalEvent: #aSetter
        with: anObject.
    ^aSetter'!    !



!GsMethodGenerator class methods !

   
generateMethodForSetter: aString
    forClass: aClass

    | myString result |

    (aClass isNil
        or:[(aClass isClass not
            or:[aString isString not ])])
                ifTrue:[^false].

        myString := self setterTemplate replaceSubstring: 'aSetter' with: aString.
        result := aClass compile: myString.

    result isNil
        ifTrue: [^false]
        ifFalse: [
            Smalltalk
                logSource: myString
                forSelector: ((aString,':') asSymbol)
                inClass: aClass.
                ^true]! !



!GsMethodGenerator class methods !

   
generateMethodForGetter: aGetterStringWithoutSymbol
    forClass: aClass

    | myString result |

    (aClass isNil
        or:[(aClass isClass not
            or:[aGetterStringWithoutSymbol isString not ])])
                ifTrue:[^false].

        myString := self getterTemplate replaceSubstring: 'aGetter' with: aGetterStringWithoutSymbol.
        result := aClass compile: myString.

    result isNil
        ifTrue: [^false]
        ifFalse: [
            Smalltalk
                logSource: myString
                forSelector: aGetterStringWithoutSymbol asSymbol
                inClass: aClass.
                ^true]! !



!GsMethodGenerator class methods !

   
getterTemplate

^'aGetter
    "Generated getter for aGetter"

    ^aGetter'!   !



!GsMethodGenerator class methods !

   
openGenerationSelectionWindowOn: aClass withView: aView

    ^GsMethodGeneratorSelectionView newOn: aClass withView: aView.!  !



!GsMethodGenerator class methods !

   
partSetterTemplate

^'aSetter: anObject
    "Generated part setter for aSetter"

     (self paneNamed: ''aSetter'') contents: anObject.

     ^(self paneNamed: ''aSetter'') contents'!  !



!GsMethodGenerator class methods !

   
generateMethodForPartGetter: aString
    forClass: aClass

    | myString result |

    (aClass isNil
        or:[(aClass isClass not
            or:[aString isString not ])])
                ifTrue:[^false].

        myString := self partGetterTemplate replaceSubstring: 'aGetter' with: aString.
        result := aClass compile: myString.

    result isNil
        ifTrue: [^false]
        ifFalse: [
            Smalltalk
                logSource: myString
                forSelector: aString asSymbol
                inClass: aClass.
                ^true]! !



!GsMethodGenerator class methods !

   
generateMethods: anOCofMethodNames  forClass: aClass

    | result |

    result := true.
    aClass isNil
        ifFalse:[
            anOCofMethodNames
                do:[:eachInstVarName |
                    (eachInstVarName includes: $:)
                        ifFalse:[
                           result := self generateMethodForGetter: eachInstVarName forClass: aClass.
                           result ifFalse:[^false]]
                        ifTrue:[
                            result := self generateMethodForSetter: (eachInstVarName select:[:e | e ~= $:]) forClass: aClass.
                            result ifFalse:[^false]]]].
    ^result! !



!GsMethodGenerator class methods !

   
partGetterTemplate

^'aGetter
    "Generated part getter for aGetter"

     ^(self paneNamed: ''aGetter'') contents'!  !



!GsMethodGenerator class methods !

   
generateMethodForPartSetter: aString
    forClass: aClass

    | myString result |

    (aClass isNil
        or:[(aClass isClass not
            or:[aString isString not ])])
                ifTrue:[^false].

        myString := self partSetterTemplate replaceSubstring: 'aSetter' with: aString.
        result := aClass compile: myString.

    result isNil
        ifTrue: [^false]
        ifFalse: [
            Smalltalk
                logSource: myString
                forSelector: ((aString,':') asSymbol)
                inClass: aClass.
                ^true]! !
